#!/bin/bash

home() {
	#local me=`basename "$0"`
	dirname ${BASH_SOURCE[0]}
	#local me=`dirname ${BASH_SOURCE[0]}`
	#local utility_path=$(echo "`dirname \"$(which $me))\"`")
	#echo $utility_path # return value
	}

host() {
	uname -n #$HOSTNAME
	#local host="$(cat $(home)/.cfg/default | sed -E -n 's/^host=([^#]*)/\1/p' | tr -d '\r')" # host alias (with remove trailing new line came from windows)
	echo $host # return value
	}

get_repos () {
	local repos=$1
	if [[ "$repos" == "" ]]; then
		repos="$(cat $(home)/.cfg/$host/default | sed -E -n 's/^default_list=([^#]*)/\1/p' | tr -d '\r')"
	 fi
	echo "$repos" # return value
	}
find_prj () {
	local root=$1
	local prj=$2
	[[ "$root" == "" ]] && echo "[LIB: FIND PROJECT] root for project is missed !" 1>&2 && return
	[[ "$prj" == "" ]] && echo "[LIB: FIND PROJECT] project name is missed !" 1>&2 && return
	#echo "root:$root"
	#echo "prj:$prj"
	(
	cd $root
	find_path="find"; [[ "$TERM" == "cygwin" ]] && find_path="$EXEPATH/usr/bin/find"
	for prj_loop in $($find_path . -maxdepth 1 -type f ! -name "*.*" | sed 's/^\.\///' ); do #; echo "prj_loop: $prj_loop"
		if [[ "$prj" == "$prj_loop" ]]; then
			echo $prj_loop
			exit
		  fi
	  done
	)
  }

# тильда в пути в переменной - крэшит параметр для команд (cd ls ..)
	# eval - http://stackoverflow.com/questions/11065077/eval-command-in-bash-and-its-typical-uses 
	# re="~(.*)"; if [[ $path =~ $re ]]; then  path=${BASH_REMATCH[1]}; fi; cd $HOME$path

find_prj_by_path () {
	local trace=$3
	local root=$1; [ "$trace" == "1" ] && echo "root:$root" 1>&2
	local path=$2; [ "$trace" == "1" ] && echo "path:$path" 1>&2
	[[ "$root" == "" ]] && echo "[LIB: FIND PROJECT BY PATH] root for project is missed !" 1>&2 && return
	[[ "$path" == "" ]] && echo "[LIB: FIND PROJECT BY PATH] path is missed !" 1>&2 && return
	
	
	(
	cd $root
	#[ $trace -eq 1] &&  pwd > 2
	find_path="find"; [[ "$TERM" == "cygwin" ]] && find_path="$EXEPATH/usr/bin/find"
	for prj_loop in $($find_path . -maxdepth 1 -type f ! -name "*.*" | sed 's/^\.\///' ); do #; echo "prj_loop: $prj_loop"
		[ "$trace" == "1" ] && echo -n "$prj_loop: $prj_path " 1>&2
		prj_path=`eval echo $(sed -E -n 's/^path=([^#]+).*/\1/p' $home/.cfg/$host/$prj_loop | tr -d '\r')` ; [ "$trace" == "1" ] && echo "prj_path: $prj_path" 1>&2
		if [[ "$path" == "$prj_path" ]]; then
			echo $prj_loop
		  fi
	  done
	)
  }

find_path_by_name () {
	local root=$1
	local prj=$2
	[[ "$root" == "" ]] && echo "[LIB: FIND PROJECT PATH] root for project is missed !" 1>&2 && return #; echo "root:$root" 1>&2
	[[ "$prj" == "" ]] && echo "[LIB: FIND PROJECT PATH] project name is missed !" 1>&2 && return #; echo "prj:$prj" 1>&2
	(
	cd $root
	find_path="find"; [[ "$TERM" == "cygwin" ]] && find_path="$EXEPATH/usr/bin/find"
	for prj_loop in $($find_path .  -maxdepth 1 -type f ! -name "*.*" | sed 's/^\.\///' ); do  #| tr -d '\r'
		#echo "prj_loop: $prj_loop" 1>&2
		if [[ "$prj" == "$prj_loop" ]]; then
			local prj_path=`eval echo $(sed -E -n 's/^path=([^# ]+).*/\1/p' $home/.cfg/$host/$prj_loop | tr -d '\r')` # remove tilda for home path's
			echo $prj_path
			exit
		  fi
	  done
	)
  }

projects_state(){
	local prj_list=$1
	local remote_mode=$2
	local trace=$3
	[[ "$trace" == "" ]] && trace=0
	local home=$(home); [ "$trace" == "1" ] && echo home: $home
	local host=$(host); [ "$trace" == "1" ] && echo host: $host
	[[ "$prj_list" == "default" ]] && prj_list=$(get_repos) ; [ "$trace" == "1" ] && echo prj_list: $prj_list
	[[ "$remote_mode" == "" ]] && -e "${red}[lib-prj.:projects_state] 'remote_mode' param is not defined !${norm} " && exit

	for prj in $(cat $home/.cfg/$host/$prj_list.list | sed -e /^$/d | tr -d '\r' | sort); do 
		prj=`echo $prj` # normalize
		prj_file=`echo $home/.cfg/$host/$prj`
		if [[ ! -f "$prj_file" ]]; then
			#echo prj: $home/.cfg/$host/$prj
			#cat $home/.cfg/$host/$prj
			echo -e "${red} Project file '$prj_file' not found !${norm} "
			continue
		  fi

		path=`sed -E -n 's/^path=([^#]+).*/\1/p' $prj_file | tr -d '\r'` ;[ $trace -eq 1 ] && echo path: $path
		[[ ! -d $path ]] && echo -e "${red} Project path '$path' not found !${norm} " && continue
		(
		eval cd "$path"
		changes=$(gis | wc -l) ; [ $trace -eq 1 ] && echo changes: $changes
		#	echo -e "${grey}$prj: $path${norm}"
		#  else
		echo -e "\n${grey_back} $prj_list  $prj \t $path ${norm}"
		if [ $changes -ne 0 ]; then
			git status -s --untracked-files
		  fi
		LOCAL=$(git rev-parse @)
		if [[ "$remote_mode" == "1" ]]; then
			REMOTE=$(git ls-remote 2>/dev/null | awk "/HEAD/ {print \$1}")
		  else
			REMOTE=$(git rev-parse @{u}) # from local
		  fi
		BASE=$(git merge-base @ @{u})
		#echo LOCAL:$LOCAL REMOTE:$REMOTE BASE:$BASE
		if [ $LOCAL = $REMOTE ]; then
			true #echo "Up-to-date"
		  elif [ $LOCAL = $BASE ]; then
			echo -e "${yellow} NEED TO PULL !${norm}"
		  elif [ $REMOTE = $BASE ]; then
			true #echo "Need to push"
		  else
			echo -e "${red_bright}DIVERGED !!${norm}"
		  fi
		)
	  done
	echo
}