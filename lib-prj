#!/bin/bash
#set -x

# globals: ==============================
TRACE=0
UTILS_PRJ_HOME=$(dirname ${BASH_SOURCE[0]})
UTILS_PRJ_CONFIGS=`eval echo ~/.utils-prj` # fix '~' bug
UTILS_PRJ_THE_HOST=$(uname -n)
UTILS_PRJ_INCLUDE="utils-prj-include"
UTILS_PRJ_ALIASES="utils-prj-aliases"

alias trace_prj='[ "$TRACE" == "1" ] && echo -e '

# TODO: =================================

	# todo: oldpwd for *nix (~/.oldpwd for msys only)
	# pmove to another list
	# correct cmd_edit_host_config
	# rename list to set in helps ??
	# pcmd <prj> (execute cmd in prj home folder)
	# cmd_add_project(){ $3 - home_path
	# verbose to TRACE
	# empty params -> help
	# plist add help header
	# get_sync_status - both mode(pull/push)
	# get_find_path
	# local looped and other
	# избавиться от APPS_ROOT (проставлять при setup)
	# ругаться если dir:utils-prj not found || "$UTILS_PRJ_HOME/lib-prj" not found || "$HOME/.utils-prj/utils-prj-aliases" not found
	# version
	# pstatex - show all remotes/ all branches

	# unite cmd_state_of_one_project cmd_state_of_all_projects
	# unite save save_all
	# unite get get_all 
	# unite get w/state
	# unite sync
	# unite fix with save
	# ~ fix one/all
	# (cut <CR>) when read from configs (prj/list)
	# add binds  Ctrl+Shift ??
	# detect project if home path is superfolder for current 
	# в каждую команду --help -h -? -verbose (trace)
	# вынести add prj to set в func - проверять что его там нет 
	# default переделать на $DEFAULT="~default"
	# psaveall <list1>,<list2>

	# plist pshow psets - use notice if no found
	# add support comment for cfg (prj/list)
	# add 'cfg' extension for prj/list files?
	# dyna gif help w/ref impl for another my prj (eg. utils-vcs)
	# cmd_project_delete +from_list

	# add beta satus, version & lic info

	# support named params style: -v -h -n: -p: -l:(-s?) -m:"" 
	# -n=<prj> -p=<path> -t=<type> -r=<remote> -l(s?)=<list(set?)>
	#while :
	#do
	#    case "$1" in
	#    -h|--help) ;;
	#    -*) echo "invalid argument $1";;
	#    *) break;;
	#    esac
	#    shift
	#done
	# prj - opt: switch to branch (ex v2.0)
		# todo: add matrix of using cmd_<utils-git>
	# todo: when cmd_<utils-git> absent - show not found msg and prompt how to install
	# todo: trace_prj ".."

	# todo: how add to repo 4 install by installer (brew apt-get)
	# todo: prj type: rsync  svn  simple(compare size / timestamp)

	# todo: reference impl : clone setup psetadd cd padd plist cd- pgo touch pstate pstx pget psave psync pcmd (reset) ...
		# how todo remote commit (w/o push)

# release notes: ========================
	# тильда в переменной для указания в пути домашней папки- крэшит команды (cd, ls ..)
		# workaround: eval - http://stackoverflow.com/questions/11065077/eval-command-in-bash-and-its-typical-uses 
		# re="~(.*)"; if [[ $path =~ $re ]]; then  path=${BASH_REMATCH[1]}; fi; cd $HOME$path
	# if you want edit lib-prj and then TRACE it, you can use next cmd: preload; TRACE=1; <cmd>; TRACE=0

# install functions======================
utils-prj-setup(){
	# обновляем файлы если уже есть
	[ ! -d ~/.utils-git ] && echo "to run commands on git repos required utils-git"
	[ ! -d ~/.utils-env ] && echo "to get messages in colored manner required utils-env"

	[ ! -d "$UTILS_PRJ_CONFIGS" ] && mkdir "$UTILS_PRJ_CONFIGS"
	[ ! -f "UTILS_PRJ_CONFIGS/$utils_include" ] && 	copy "$UTILS_PRJ_HOME/$UTILS_PRJ_INCLUDE" "UTILS_PRJ_CONFIGS/$UTILS_PRJ_INCLUDE"
	# sed REPLACE path in 'export HOME_UTILS_PRJ= ex to "/C/app/utils-prj"
	[ ! -f "UTILS_PRJ_CONFIGS/$UTILS_PRJ_ALIASES" ] && copy "$UTILS_PRJ_HOME/$UTILS_PRJ_ALIASES" "UTILS_PRJ_CONFIGS/$UTILS_PRJ_ALIASES"
	# sed UTILS_PRJ_HOME in 'include' # to include lib to shell and some commands (ex. pel, p-help)
	local bash_profile=`eval echo ~/.bash_profile` # fix ~ bug
	touch "$bash_profile"
	# [ if not found '. ~/.utils-prj/include ] && echo '. ~/.utils-prj/include' >> .bash_profile
	# echo "add to PATH?" read  [] echo "export PATH=$PATH:$UTILS_PRJ_HOME" >> $utils_include
	mkdir "$UTILS_PRJ_CONFIGS/$UTILS_PRJ_THE_HOST"
	[ ! -f "UTILS_PRJ_CONFIGS/$UTILS_PRJ_THE_HOST/default" ] && copy "$UTILS_PRJ_HOME/default" "UTILS_PRJ_CONFIGS/$UTILS_PRJ_THE_HOST/default"
	touch "UTILS_PRJ_CONFIGS/$UTILS_PRJ_THE_HOST/!projects"
	echo 'p-help' - print readme.adoc
	echo "'pshow' - print current configuration (config files, project sets with projects)"
	echo "'padd my_alias' - add alias and current folder to projects list (at start - 'default')"
	echo 'plist' - review assigned aliases
	echo 'pgo my_alias' - cmd_project_go home
	echo 'pfix my_alias' - save project at local repository
	echo 'psave my_alias' - save project and sync with remote repository
	echo 'pget my_alias' - pull project from remote repository
	}
utils-prj-uninstall(){
	# cut '. ~/.utils-prj/include' from .bash_profile
	rm "UTILS_PRJ_CONFIGS/$UTILS_PRJ_INCLUDE"
	rm "UTILS_PRJ_CONFIGS/$UTILS_PRJ_ALIASES"
	# echo remove host aliases also ?; read; 
		# rm -r -f "$UTILS_PRJ_CONFIGS/$UTILS_PRJ_THE_HOST"
		# cd "UTILS_PRJ_CONFIGS/.."
		# rm "UTILS_PRJ_CONFIGS"
	cd "$UTILS_PRJ_HOME"/..
	rm "$UTILS_PRJ_HOME"
	}

# service functions======================
get_current_set () {
	local project_list=$1
	if [[ "$project_list" == "" ]]; then
		project_list="$(sed -E -n 's/^default_list=([^#]*)/\1/p' "$UTILS_PRJ_CONFIGS/$UTILS_PRJ_THE_HOST/default" | tr -d '\r')"
	 fi
	echo "$project_list" # return value
	}
get_current_project () {
	get_project_name "$(pwd)"
	}
get_project_name_verified () { 	# <prj>
	local prj=$1
	trace_prj "prj:\t\t$prj [get_project_name_verified]" 1>&2
	[[ "$prj" == "" ]] && echo "[get_project_name_verified] project name is missed !" 1>&2 && return
	
	( # to restore path after cd
	cd "$UTILS_PRJ_CONFIGS/$UTILS_PRJ_THE_HOST"
	find_path="find" # linux/osx
	[[ "$TERM" == "cygwin" ]] && find_path="$(cygpath-m "$EXEPATH")/usr/bin/find" # in windows $EXEPATH ex. C:\app\git - std env by git bash
	#$(cygpath-m "$EXEPATH") or canonpath after correct
	trace_prj "find_path:\t$find_path [get_project_name_verified]" 1>&2

	for prj_loop in $($find_path . -maxdepth 1 -type f ! -name "*.*" -a ! -name default -exec basename "{}" ';'); do # all files w/o extensions ; sed -cut './' in name    | sed 's/^\.\///' 
		trace_prj "prj_loop:\t$prj_loop [get_project_name_verified]" 1>&2
		if [[ "$prj" == "$prj_loop" ]]; then
			echo $prj_loop # return alias (name) of project if found
			return
		  fi
	  done
	)
  }
get_project_name () { # <project_path>
	# to test - bp; TRACE=1;get_project_name "/c/app/utils-env"
	local project_path=$1; 
	[ "$2" != "" ] && local TRACE=$2
	#trace_prj "root:\t\t$UTILS_PRJ_CONFIGS/$UTILS_PRJ_THE_HOST" 1>&2 # local root=$1; 
	#trace_prj "project_path:\t$project_path [get_project_name]" 1>&2
	#[[ "$root" == "" ]] && echo "[LIB: FIND PROJECT BY PATH] root for project is missed !" 1>&2 && return
	[[ "$project_path" == "" ]] && project_path=$(pwd)
	trace_prj "project_path:\t$project_path [get_project_name]" 1>&2
		#echo "[get_project_name] project_path is missed !" 1>&2 && return
	
	(
	cd "$UTILS_PRJ_CONFIGS/$UTILS_PRJ_THE_HOST" #[ $TRACE -eq 1 ] &&  pwd 
	find_path="find"
	[[ "$TERM" == "cygwin" ]] && find_path="$(cygpath-m "$EXEPATH")/usr/bin/find"
	trace_prj "find_path:\t$find_path [get_project_name]" 1>&2
	for prj_loop in $($find_path . -maxdepth 1 -type f ! -name "*.*" -a ! -name default -exec basename "{}" ';'); do # all files w/o extensions | sed 's/^\.\///'
		trace_prj -n "prj_loop:\t$prj_loop [get_project_name]" 1>&2
		looped_path=`eval echo $(sed -E -n 's/^path=([^#]+).*/\1/p' $UTILS_PRJ_CONFIGS/$UTILS_PRJ_THE_HOST/$prj_loop | tr -d '\r')` 
		trace_prj "\tlooped_path:\t$looped_path [get_project_name]" 1>&2
		if [[ "$project_path" == "$looped_path" ]]; then
			echo $prj_loop
			return
		  fi
	  done
	)
  }
get_project_path () {	# <prj>
	local prj=$1
	[ "$3" != "" ] && local TRACE=$2
	local extra=$3
	[ "$extra" != "" ] && echo "[get_project_path] extra param is invalid!" 1>&2 && (trace_prj "extra:\t$extra [get_project_path]" 1>&2) && return 
	#[[ "$root" == "" ]] && echo "[LIB: FIND PROJECT PATH] root for project is missed !" 1>&2 && return ; trace_prj "root:\t\t$root [get_project_path]" 1>&2
	[[ "$prj" == "" ]] && echo "[get_project_path] project name is missed !" 1>&2 && (trace_prj "prj:\t\t$prj [get_project_path]" 1>&2) && return
	(
	cd "$UTILS_PRJ_CONFIGS/$UTILS_PRJ_THE_HOST"
	local find_path="find"
	[[ "$TERM" == "cygwin" ]] && find_path="$(cygpath-m "$EXEPATH")/usr/bin/find"
	trace_prj "find_path:\t$find_path [get_project_path]" 1>&2
	for prj_loop in $($find_path . -maxdepth 1 -type f ! -name "*.*" -a ! -name default -exec basename "{}" ';'); do  #| tr -d '\r' | sed 's/^\.\///' 
		trace_prj "prj_loop:\t$prj_loop [get_project_path]" 1>&2
		if [[ "$prj" == "$prj_loop" ]]; then
			local prj_path=`eval echo $(sed -E -n 's/^path=([^# ]+).*/\1/p' $UTILS_PRJ_CONFIGS/$UTILS_PRJ_THE_HOST/$prj_loop | tr -d '\r')` # remove tilda for home path's
			echo $prj_path
			return
		  fi
	  done
	)
  }
get_sync_status(){		# <remote_mode>
	# ex. get_sync_status true # to compare with last commit from remote host
	# ??todo: return two out param ???  array?  or  pull/push/both/diverged only?
	local use_remote_host=$1  	# true / false
	local result_format=$2 		# when 'silent' then print yes/no else print msg for user 
	[ "$3" != "" ] && local TRACE=$3

	[ "$result_format" == "" ] && result_format=simple
	[ "$use_remote_host" == "" ] && use_remote_host=false
	[ "$use_remote_host" == "remote" ] && use_remote_host=true
	trace_prj "use_remote_host:$use_remote_host [get_sync_status]" 1>&2
	trace_prj "result_format:\t$result_format [get_sync_status]" 1>&2
	#trace_prj $([ "$result_format" != "silent" ] && echo "notice mode [get_sync_status]") 1>&2
	local status
	local LOCAL=$(git rev-parse @)
	if [[ "$use_remote_host" == "true" ]]; then
		local REMOTE=$(git ls-remote 2>/dev/null | awk "/HEAD/ {print \$1}") # from remote host
	  else
		local REMOTE=$(git rev-parse @{u}) # last pulled head of remote
	  fi
	local BASE=$(git merge-base @ @{u})
	#echo LOCAL:$LOCAL REMOTE:$REMOTE BASE:$BASE
	if [ $LOCAL = $REMOTE ]; then 		status="ok" 
	  elif [ $LOCAL = $BASE ]; then		status="pull"
	  elif [ $REMOTE = $BASE ]; then	status="push"
	  else				  	status="diverged"
	  fi
	echo "$status"
	[ "$result_format" != "silent" ] && show_sync_status "$status"
	}
show_sync_status(){
	local sync_status=$1
	[ "$sync_status" == "pull" ] 	 && echo -e "${yellow} NEED TO PULL !${norm}" 1>&2
	[ "$sync_status" == "push" ] 	 && echo -e "${green} NEED TO PUSH${norm}" 1>&2
	[ "$sync_status" == "diverged" ] && echo -e "${red_bright} DIVERGED !!${norm}" 1>&2 # ! NEED TO PUSH AFTER
	# [ "$sync_status" == "ok" ] && 
	}
get_project_or_list(){	# <prj|list>
	local project_or_list=$1  	# true / false
	[ "$project_or_list" == "" ] && echo -e "${red}[get_project_or_list] param 'project_or_list' is missed !${norm}" && return 

	local find_path="find" # linux/osx
	[[ "$TERM" == "cygwin" ]] && find_path="$(cygpath-m "$EXEPATH")/usr/bin/find" # in windows $EXEPATH ex. C:\app\git - std env by git bash
	trace_prj "find_path:\t$find_path [cmd_set_enum]" 1>&2

	(
	cd "$UTILS_PRJ_CONFIGS/$UTILS_PRJ_THE_HOST"
	local fname
	for fname in $($find_path . -maxdepth 1 -type f ! -name default -exec basename "{}" ';'); do
		#fname=`echo $fname` #normalize (cut <CR>)
		trace_prj "fname:\t$fname [cmd_set_enum]" 1>&2
		#path=`sed -E -n 's/^path=([^#]+).*/\1/p' $UTILS_PRJ_CONFIGS/$UTILS_PRJ_THE_HOST/$prj_list | tr -d '\r'` 
		local filename=$(echo "${fname%.*}"); trace_prj "filename:\t$filename [cmd_set_enum]" 1>&2
		local extension="${fname##*.}"; trace_prj "extension:\t$extension [cmd_set_enum]" 1>&2
		if [ "$filename" == "$project_or_list" ]; then
			if [ "$extension" == "list" ]; then
				echo "set"
			  else
				echo "project"
			  fi
			return
		  fi
	  done
	)
	}

# config functions ======================
cmd_show_current_config(){	# pshow
	true
	# version
	# папка home
	# папка config
	# path with host's configs (files: aliases , include /PATH/ )
	# p-help 
	# psets (one lined style)
	}
cmd_project_enum(){		# plist	[<list>]
	# plist <list>
	# echo UTILS_PRJ_THE_HOST: $UTILS_PRJ_THE_HOST
	prj_list=$1
	prj_list=$(get_current_set $prj_list); trace_prj "prj_list:\t$prj_list"
	echo -e "\n${grey_back}          $prj_list          ${norm}"

	for prj_name in $(cat $UTILS_PRJ_CONFIGS/$UTILS_PRJ_THE_HOST/$prj_list.list | sed -e /^$/d | tr -d '\r' | sort); do 
		#prj_name=`eval echo $prj_name` # normalize (<CR> ~)
		local path=`sed -E -n 's/^path=([^#]+).*/\1/p' $UTILS_PRJ_CONFIGS/$UTILS_PRJ_THE_HOST/$prj_name | tr -d '\r'`
		echo -e "$prj_name:\t$path"
	  done
	echo
	}
cmd_project_add(){		# padd	<prj> [<list>]
	# cmd_add_project -n=<prj> -p=<path> -t=<type> -r=<remote> -s=<set>
	local prj_name=$1
	local prj_list=$2

	[[ "$prj_name" == "" ]] && echo -e "${red}[cmd_project_add] prj_name param is missed !${norm}" && return 
	local curr_path="${PWD/#$HOME/~}"; trace_prj "cur_path:\t$curr_path"
	
	# TODO: detect repo type (git/svn/hg - .git foder / .svn folder? / ..)
	# TODO: return when curr_path not repo
	# TODO: test prj_name in list
	# TODO: detect tail CR and don't append \n
	# TODO: if file exists but absent in default list then add

	#trace_prj "home:\t\t$UTILS_PRJ_HOME"; trace_prj "UTILS_PRJ_THE_HOST:\t\t$UTILS_PRJ_THE_HOST"

	if [[ "$prj_list" == "" ]]; then
		prj_list_default=$(get_current_set); trace_prj "default_list:\t$prj_list_default"
		[ "$prj_list_default" == "" ] && echo -e "${red}[cmd_project_add] prj_list_default not found !${norm}" && return
		prj_list="$prj_list_default.list"
	  else
	  	prj_list="$prj_list.list"
	  fi; trace_prj "prj_list:\t$prj_list"
		
	prj_file="$UTILS_PRJ_CONFIGS/$UTILS_PRJ_THE_HOST/$prj_name"; trace_prj "prj_file:\t$prj_file"
	[[ -f $prj_file ]] && echo -e "${red}[cmd_project_add] Project already exists${norm}" && return

	echo "path=$curr_path" 	> $prj_file
	echo "type=git" 	>> $prj_file
	echo "remote=" 		>> $prj_file

	echo -e "$prj_name" >> "$UTILS_PRJ_CONFIGS/$UTILS_PRJ_THE_HOST/$prj_list" # ? test to exists?
	echo -e "[cmd_project_add] Project ${green}$prj_name ($curr_path${norm}) added to ${green}$prj_list${norm}" # ? test to exists?
	# shift loop
	# if $prj_name == "" then folder
	# if $path == "" then pwd
	# if $type == "" then git
	# if $remote == "" then current
	# if $set == "" then default
	}
cmd_project_delete(){		# pdel -n=<prj> -p=<path> -s=<set>
	# alias pcfg='cmd_cfg' ???
	# pcfg <option>=<value>
	# pcfg --switch_default_prj_list=<prj_list>
	# pcfg --default_project=<prj>

	# shift loop
	# if $path == "" then pwd
	# if $prj == "" then folder
	# if $set == "" then default

	# if path == $path then rm
	local prj_name="$1"
	#[[ "$prj_name" == "" ]] && echo -e "${red}[cmd_project_delete] prj_name param is missed !${norm}" && return 
	[ "$prj_name" == "" ] && prj_name=$(get_current_project) # .
	[[ ! -f "$UTILS_PRJ_CONFIGS/$UTILS_PRJ_THE_HOST/$prj_name" ]] && echo -e "[cmd_project_delete] Project '${red}$UTILS_PRJ_CONFIGS/$UTILS_PRJ_THE_HOST/$prj_name${norm}' not found !" && return 
	prj_path=`sed -E -n 's/^path=([^#]+).*/\1/p' $UTILS_PRJ_CONFIGS/$UTILS_PRJ_THE_HOST/$prj_name | tr -d '\r'`
	#prj_type=`sed -E -n 's/^type=([^#]+).*/\1/p' $UTILS_ PRJ_CONFIGS/$UTILS_PRJ_THE_HOST/$prj_name | tr -d '\r'`
	#prj_remote=`sed -E -n 's/^remote=([^#]+).*/\1/p' $UTILS_PRJ_CONFIGS/$UTILS_PRJ_THE_HOST/$prj_name | tr -d '\r'`
	rm "$UTILS_PRJ_CONFIGS/$UTILS_PRJ_THE_HOST/$prj_name" || return
	sed -E -i "s/^$prj_name$//g" "$UTILS_PRJ_CONFIGS/$UTILS_PRJ_THE_HOST/$(get_current_set).list" && echo -e "[cmd_project_delete] Project ${yellow}$prj_name ($prj_path)${norm} is deleted" 
	}
cmd_project_move(){		# pmove	<prj>|. [<list>]
	# if list is skipped and prj_name is same 					-> update prj path
	# if list is skipped and prj_name is different from stored (find by path) 	-> upd name of prj (name and link in list)
	# if prj_name is same and list is different 					-> cut prj from current list and paste to pointed list

	local prj_name="$1"
	local prj_list="$2"
	#[[ "$prj_name" == "" ]] && echo -e "${red}[PROJECT MOVE] Project name is missed !${norm}" && return

	#new_path=$(pwd) #; echo new_path: $new_path
	local curr_path="${PWD/#$HOME/~}" # replace $HOME to ~

	# TODO: detect repo type (git/svn/hg - .git foder / .svn folder? / ..) and return if new_path not a repo 

	if [ "$prj_list" == "" ]; then
		local prj_list="$(get_current_set).list"
		local project_name=$(get_project_name); trace_prj "project_name:\t$project_name"
		[ "$project_name" == "" ] && echo -e "${red}Project not found by '$curr_path'${norm}" && return
		if [ "$project_name" == "$prj_name" ]; then
			# update prj path
			sed -i -E "s/^(path=)(.*)/\1${curr_path//\//\\/}/g" "$UTILS_PRJ_CONFIGS/$UTILS_PRJ_THE_HOST/$prj_name" || return #  replace home path
		  else
			# upd name of prj (name and link in list)
			[ -f "$UTILS_PRJ_CONFIGS/$UTILS_PRJ_THE_HOST/$prj_name" ] && echo -e "${red}Project '$UTILS_PRJ_CONFIGS/$UTILS_PRJ_THE_HOST/$prj_name' already exist ${norm}"
			local found=$(grep "^$project_name$" "$UTILS_PRJ_CONFIGS/$UTILS_PRJ_THE_HOST/$prj_list")
			trace_prj "found:\t$found"
			[ "$found" != "$project_name" ] && echo -e "${red}Project '$UTILS_PRJ_CONFIGS/$UTILS_PRJ_THE_HOST/$prj_name' not found in '$UTILS_PRJ_CONFIGS/$UTILS_PRJ_THE_HOST/$prj_list' ${norm}" && return
			mv "$UTILS_PRJ_CONFIGS/$UTILS_PRJ_THE_HOST/$project_name" "$UTILS_PRJ_CONFIGS/$UTILS_PRJ_THE_HOST/$prj_name" || return
			sed -i -E "s/^$project_name$/$prj_name/g" "$UTILS_PRJ_CONFIGS/$UTILS_PRJ_THE_HOST/$prj_list" || return
		  fi
	  else
		# cut prj from current list and paste to pointed list
		[ "$prj_name" == "." ] && prj_name=$(get_project_name); trace_prj "prj_name:\t$prj_name"
		local current_set=$(get_current_set); trace_prj "current_set:\t$current_set"
		[[ ! -f "$UTILS_PRJ_CONFIGS/$UTILS_PRJ_THE_HOST/$prj_list.list" ]] && echo -e "${red}[cmd_project_move] Project list '$UTILS_PRJ_CONFIGS/$UTILS_PRJ_THE_HOST/$prj_list.list' not found !${norm}" && return
		echo "$prj_name" >> "$UTILS_PRJ_CONFIGS/$UTILS_PRJ_THE_HOST/$prj_list.list"
		echo -e "[cmd_project_move] Project ${green}$prj_name${norm} added to ${green}'$UTILS_PRJ_CONFIGS/$UTILS_PRJ_THE_HOST/$prj_list.list'${norm}" 
		sed -i -E "s/^$prj_name$//g" "$UTILS_PRJ_CONFIGS/$UTILS_PRJ_THE_HOST/$current_set.list" || return
		echo -e "[cmd_project_move] Project ${yellow}$prj_name${norm} cut from ${yellow}'$UTILS_PRJ_CONFIGS/$UTILS_PRJ_THE_HOST/$current_set.list'${norm}" 
  fi
	cmd_project_enum # plist
	}
cmd_project_rename(){		# ren 		<prj>
	# pren <prj> [<list>]  - rename prj name (alias) (find prj by curr_path)
	# pren -n=<prj> -p=<path> -t=<type> -r=<remote> -s=<set>

	#TRACE=0
	new_prj_name=$1
	[[ "$new_prj_name" == "" ]] && echo -e "${red}[cmd_project_rename] Project name not found !${norm}" && return
	#list=$2

	#new_path=$(pwd) #; echo new_path: $new_path
	curr_path="${PWD/#$HOME/~}" # replace $HOME to ~

	# TODO: detect repo type (git/svn/hg - .git foder / .svn folder? / ..) and return if new_path not a repo 

	#trace_prj "UTILS_PRJ_HOME:\t$UTILS_PRJ_HOME" 
	#trace_prj "UTILS_PRJ_THE_HOST: $UTILS_PRJ_THE_HOST"

	if [[ "$list" == "" ]]; then
		prj_list=$(get_current_set).list 
	  else
	  	prj_list="$list.list"
	  fi
	trace_prj"prj_list:\t$prj_list"
	# TODO: test prj in list
	#return
	curr_path=`eval echo $curr_path` # replace '~'' -> $HOME

	curr_prj_name=$(get_project_name $curr_path $TRACE) ; trace_prj "curr_prj_name:\t$curr_prj_name"	 #old prj name
	[[ "$curr_prj_name" == "" ]] && echo -e "${red}[cmd_project_rename] Project file not found !${norm}" && return
	  #prj_path=`sed -E -n 's/^path=([^#]+).*/\1/p' $UTILS_PRJ_CONFIGS/$UTILS_PRJ_THE_HOST/$new_prj_name | tr -d '\r'` #; echo curr_path: $prj_path
	#echo sed -i "s/^$curr_prj_name\$/$new_prj_name/g" "$UTILS_PRJ_CONFIGS/$UTILS_PRJ_THE_HOST/$prj_list" ; return
	mv "$UTILS_PRJ_CONFIGS/$UTILS_PRJ_THE_HOST/$curr_prj_name" "$UTILS_PRJ_CONFIGS/$UTILS_PRJ_THE_HOST/$new_prj_name" || return

	sed -i -E "s/^$curr_prj_name\$/$new_prj_name/g" "$UTILS_PRJ_CONFIGS/$UTILS_PRJ_THE_HOST/$prj_list" || return # sed -i "s/^jr$/jrhw/g" `echo $UTILS_PRJ_CONFIGS/$UTILS_PRJ_THE_HOST/$(get_current_set).list`

	#echo "path=$new_path" 	>  $prj_path
	#echo "type=git" 	>> $prj_file
	#echo "remote=" 		>> $prj_file

	cmd_project_enum

	# TODO: if file exists but absenr in default list then add

	# shift loop
	# if $new_prj_name == "" then folder
	# if $path == "" then pwd
	# if $type == "" then git
	# if $remote == "" then current
	# if $set == "" then default
	}

cmd_set_enum(){		# psets
	#echo -e "\n${grey_back}          project sets          ${norm}"

	local find_path="find" # linux/osx
	[[ "$TERM" == "cygwin" ]] && find_path="$(cygpath-m "$EXEPATH")/usr/bin/find" # in windows $EXEPATH ex. C:\app\git - std env by git bash
	trace_prj "find_path:\t$find_path [cmd_set_enum]" 1>&2
	local set_default=$(get_current_set)
	(
	cd "$UTILS_PRJ_CONFIGS/$UTILS_PRJ_THE_HOST"
	local prj_list
	for prj_list in $($find_path . -maxdepth 1 -type f -name "*.list" -exec  basename "{}" ';' ); do
		#prj_list=`echo $prj_list` #normalize (cut <CR>)
		#path=`sed -E -n 's/^path=([^#]+).*/\1/p' $UTILS_PRJ_CONFIGS/$UTILS_PRJ_THE_HOST/$prj_list | tr -d '\r'` 
		# prj_list=${prj_list:2}
		prj_list="${prj_list/.list/}"
		[ "$prj_list" == "$set_default" ] && prj_list="$prj_list ${green}(current)${norm}"
		echo -e "$prj_list"
		#cmd_enum_projects "$prj_list"
	  done
	)
	}
cmd_set_add() {			# psetadd	<set>
	local set_name="$1"
	[[ "$set_name" == "" ]] && echo -e "${red}[cmd_set_add] set_name param is missed !${norm}" && return 
	[[ -f "$UTILS_PRJ_CONFIGS/$UTILS_PRJ_THE_HOST/$set_name.list" ]] && echo -e "[cmd_set_add] Project list '${red}$UTILS_PRJ_CONFIGS/$UTILS_PRJ_THE_HOST/$set_name/$set_name.list${norm}' already exists !" && return 
	touch "$UTILS_PRJ_CONFIGS/$UTILS_PRJ_THE_HOST/$set_name.list"
	[ -f "$UTILS_PRJ_CONFIGS/$UTILS_PRJ_THE_HOST/$set_name.list" ] && echo -e "[cmd_set_add] Project list '${green}$UTILS_PRJ_CONFIGS/$UTILS_PRJ_THE_HOST/$set_name.list${norm}' is added" 
	}
cmd_set_delete() {		# psetdel	<set>
	local set_name="$1"
	[[ "$set_name" == "" ]] && echo -e "${red}[cmd_set_delete] set_name param is missed !${norm}" && return 
	[[ "$set_name" == "$(get_current_set)" ]] && echo -e "${red}[cmd_set_delete] You can't delete default list !${norm}" && return 
	[[ ! -f "$UTILS_PRJ_CONFIGS/$UTILS_PRJ_THE_HOST/$set_name.list" ]] && echo -e "[cmd_set_delete] Project list '${red}$UTILS_PRJ_CONFIGS/$UTILS_PRJ_THE_HOST/$set_name.list${norm}' not found !" && return 
	local prj_name
	for prj_name in $(cat $UTILS_PRJ_CONFIGS/$UTILS_PRJ_THE_HOST/$set_name.list | sed -e /^$/d | tr -d '\r' | sort); do 
		prj_name=`eval echo $prj_name`; trace_prj "prj_name:\t$prj_name" # normalize (<CR> ~)
		prj_path=`sed -E -n 's/^path=([^#]+).*/\1/p' $UTILS_PRJ_CONFIGS/$UTILS_PRJ_THE_HOST/$prj_name | tr -d '\r'`
		#prj_type=`sed -E -n 's/^type=([^#]+).*/\1/p' $UTILS_ PRJ_CONFIGS/$UTILS_PRJ_THE_HOST/$prj_name | tr -d '\r'`
		#prj_remote=`sed -E -n 's/^remote=([^#]+).*/\1/p' $UTILS_PRJ_CONFIGS/$UTILS_PRJ_THE_HOST/$prj_name | tr -d '\r'`
		# echo "delete alias $prj_name:\t$prj_path"
		[ ! -f "$UTILS_PRJ_CONFIGS/$UTILS_PRJ_THE_HOST/$prj_name" ] && echo -e "[cmd_set_delete] Project ${red}$UTILS_PRJ_CONFIGS/$UTILS_PRJ_THE_HOST/$prj_name${norm} not found " && continue
		rm "$UTILS_PRJ_CONFIGS/$UTILS_PRJ_THE_HOST/$prj_name" && echo -e "[cmd_set_delete] Project ${yellow}$prj_name${norm} for ${yellow}$prj_path${norm} is deleted" 
		# -f  ignore non-existent files, never prompt
		# -r  remove directories and their contents recursively
		# -v  explain what is being done
		# -i  prompt you on every deletion.
	  done
	rm "$UTILS_PRJ_CONFIGS/$UTILS_PRJ_THE_HOST/$set_name.list" && echo -e "[cmd_set_delete] Project list ${yellow}$UTILS_PRJ_CONFIGS/$UTILS_PRJ_THE_HOST/$set_name.list${norm} is deleted" 
	}
#cmd_move_set() {		# psetmove	<host>
cmd_set_rename() {		# psetren
	# verify or define by path
	# rename file
	# replace if default
	local set_name="$1"
	[[ "$set_name" == "" ]] && echo -e "${red}[cmd_set_rename] set_name param is missed !${norm}" && return 
	local set_name_current="$(get_current_set)"; trace_prj "set_name_current:\t$set_name_current" # normalize (<CR> ~)
	[[ ! -f "$UTILS_PRJ_CONFIGS/$UTILS_PRJ_THE_HOST/$set_name_current.list" ]] && echo -e "${red}[cmd_set_rename] Project list ${red}$UTILS_PRJ_CONFIGS/$UTILS_PRJ_THE_HOST/$set_name/$set_name.list${norm} not found !" && return 
	eval mv "'$UTILS_PRJ_CONFIGS/$UTILS_PRJ_THE_HOST/$set_name_current.list'" "'$UTILS_PRJ_CONFIGS/$UTILS_PRJ_THE_HOST/$set_name.list'" || return
	sed -i -E "s/^(default_list=)(.*)/\1$set_name/g" "$UTILS_PRJ_CONFIGS/$UTILS_PRJ_THE_HOST/default" && echo -e "[cmd_set_rename] Current project list now is ${green}$set_name${norm}" 
	}
cmd_set_switch() {		# psetsw	<list>|.  # set as default
	local set_name="$1"
	[[ "$set_name" == "" ]] && echo -e "${red}[cmd_set_switch] set_name param is missed !${norm}" && return 
	[[ ! -f "$UTILS_PRJ_CONFIGS/$UTILS_PRJ_THE_HOST/$set_name.list" ]] && echo -e "${red}[cmd_set_switch] Project list ${red}$UTILS_PRJ_CONFIGS/$UTILS_PRJ_THE_HOST/$set_name/$set_name.list${norm} not found !" && return 
	sed -i -E "s/^(default_list=)(.*)/\1$set_name/g" "$UTILS_PRJ_CONFIGS/$UTILS_PRJ_THE_HOST/default" && echo -e "[cmd_set_switch] Current project list is ${green}$set_name${norm} now"
	}

# navigate and state functions===========
cmd_project_go(){	# pgo 	<prj> [<list>?] # dubl aliases?
	# pgo <project> 
	#TRACE=0
	[ $SHLVL -gt 1 ] && echo "[cmd_project_go] Subshell can't change path after return ! CORRECT USE: '. pgo <project>'" 1>&2 && return
	#if expr match $parent $(which vim) > /dev/null

	#me=`dirname ${BASH_SOURCE[0]}` ; trace_prj"utility path: $me"
	#. $me/lib-prj

	project="$1" # test 1st param - prj name
	[[ "$project" == "" ]] && echo "[cmd_project_go] project name is missed !"

	trace_prj "UTILS_PRJ_HOME:\t$UTILS_PRJ_HOME"
	trace_prj "UTILS_PRJ_THE_HOST: $UTILS_PRJ_THE_HOST"
		# repos=$1; repos=$(get_current_set $repos) # echo repos: $repos
	#echo path: "$UTILS_PRJ_CONFIGS/$UTILS_PRJ_THE_HOST" 
	#get_project_name_verified "$UTILS_PRJ_CONFIGS/$UTILS_PRJ_THE_HOST" $project
	prj_repo=$(get_project_name_verified $project) 
	trace_prj "prj_repo:\t$prj_repo" # "$UTILS_PRJ_CONFIGS/$UTILS_PRJ_THE_HOST" 
	[[ "$prj_repo" == "" ]] && echo "[cmd_project_go] project '$project' not found !" && return
	# extract path of repo
	project_path="$(sed -E -n 's/^path=([^#]*)/\1/p' $UTILS_PRJ_CONFIGS/$UTILS_PRJ_THE_HOST/$prj_repo | tr -d '\r')" 
	trace_prj "project_path:\t$project_path"

	echo "go to: $project_path"
	# ??TODO: test $path exists
	eval cd "$project_path"
	[ "$ConEmuPID" != "" ] && $ConEmuBaseDir/ConEmuC -GuiMacro Rename 0 "${PWD##*/}" 1> /dev/null
	[ "$TERM_PROGRAM" == "Apple_Terminal" ] && echo -ne "\033]0;${PWD##*/}\007"
	}
cmd_state_of_one_project(){	# pstate[x] <prj>
	# pstate <prj>
	prj=$1
	[ "$remote_mode" == "" ] && remote_mode=false #$2

	# echo home: $home
	# echo UTILS_PRJ_THE_HOST: $UTILS_PRJ_THE_HOST
	( # to return current path
	if [[ "$prj" == "" ]]; then 
		curr_path=`eval echo $(pwd)`; trace_prj "cur_path:\t$curr_path"
		prj_name=$(get_project_name $curr_path dont_TRACE); trace_prj "prj_name:\t$prj_name"
		[[ "$prj_name" == "" ]] && echo "[SAVE PROJECT] project name is missed  and  not found by 'current path' in $UTILS_PRJ_CONFIGS/$UTILS_PRJ_THE_HOST !" && return
	  else
		# find prj file by current path
		prj_path=$(get_project_path $prj dont_TRACE) #"$UTILS_PRJ_CONFIGS/$UTILS_PRJ_THE_HOST" 
		# TODO: get prj vcs_type (svn, git)
		echo -e "$prj:\t$prj_path"
		eval cd "$prj_path"
	  fi
	gis
	sync_status=$(get_sync_status "$remote_mode" "notice" "noTRACE")
	)
	}
cmd_state_of_all_projects(){	# pst[x] <list>|. 	# '.' for default list
	local prj_list=$1
	[ "$prj_list" == "" ] && prj_list=default
	[ "$remote_mode" == "" ] && remote_mode=false #$2
	[ "$TRACE" == "" ] && local TRACE=0 #$3
	
	trace_prj "UTILS_PRJ_HOME:\t\t$UTILS_PRJ_HOME"
	trace_prj "UTILS_PRJ_THE_HOST:\t$UTILS_PRJ_THE_HOST"
	trace_prj "remote_mode:\t\t$remote_mode"
	
	[[ "$prj_list" == "default" ]] && prj_list=$(get_current_set)
	trace_prj "prj_list:\t\t$prj_list"
	#[[ "$remote_mode" == "" ]] && -e "${red}[lib-prj.:projects_state] 'remote_mode' param is not defined !${norm} " && return

	echo
	for prj in $(cat $UTILS_PRJ_CONFIGS/$UTILS_PRJ_THE_HOST/$prj_list.list | sed -e /^$/d | tr -d '\r' | sort); do 
		prj=`echo $prj` # normalize
		prj_file=`echo $UTILS_PRJ_CONFIGS/$UTILS_PRJ_THE_HOST/$prj`
		if [[ ! -f "$prj_file" ]]; then
			#echo prj: $UTILS_PRJ_CONFIGS/$UTILS_PRJ_THE_HOST/$prj
			#cat $UTILS_PRJ_CONFIGS/$UTILS_PRJ_THE_HOST/$prj
			echo -e "${red} Project file '$prj_file' not found !${norm} "
			continue
		  fi

		#prj_file=`eval echo $prj_file` # cut <CR> 
		trace_prj "prj_file:\t\t$prj_file" 

		prj_path=`sed -E -n 's/^path=([^#]+).*/\1/p' "$prj_file" | tr -d '\r'` 
		prj_path=`eval echo $prj_path` # for osx replace ~ to $HOME (and cut <CR>?)
		trace_prj "prj_path:\t\t$prj_path"
		[[ ! -d "$prj_path" ]] && echo -e "${red} Project path '$prj_path' not found !${norm} " && continue
		(
		eval cd "$prj_path"
		changes=$(gis | wc -l) 
		trace_prj "changes:\t\t$changes"
		#	echo -e "${grey}$prj: $prj_path${norm}"
		#  else

		echo -e "${grey_back} $prj_list  $prj \t $prj_path ${norm}"
		[ $changes -ne 0 ] && git status -s --untracked-files

		[ "$remote_mode" = "remote" ] && echo -n "Ask remote for last commit (hash) .. " 
		local sync_remote_status=$(get_sync_status $remote_mode "notice" no_TRACE)
		[[ "$remote_mode" = "remote" && "$sync_remote_status" == "ok" ]] && echo -e "same"
		trace_prj "sync_remote_status:\t$sync_remote_status"
		#[[ "$changes" != "0" || "$sync_remote_status" != "ok" ]] && 
		echo
		)
	  done
	}
cmd_state_of_projects(){	# psp[x] .|<prj>|<list> [<remote_mode>]?

	( # to return current path
	if [[ "$prj_or_list" == "" ]]; then 
		curr_path=`eval echo $(pwd)`; trace_prj "cur_path:\t$curr_path"
		prj_name=$(get_project_name $curr_path dont_TRACE); trace_prj "prj_name:\t$prj_name"
		[[ "$prj_name" == "" ]] && echo "[SAVE PROJECT] project name is missed  and  not found by 'current path' in $UTILS_PRJ_CONFIGS/$UTILS_PRJ_THE_HOST !" && return
	  else
		# find prj file by current path
		prj_path=$(get_project_path $prj dont_TRACE) #"$UTILS_PRJ_CONFIGS/$UTILS_PRJ_THE_HOST" 
		# TODO: get prj vcs_type (svn, git)
		echo -e "$prj:\t$prj_path"
		eval cd "$prj_path"
	  fi
	gis
	sync_status=$(get_sync_status "$remote_mode" "notice" "noTRACE")
	)
	}
cmd_project_sync(){		# prs <sync_type> .|<prj>|<list> 	# sync_type: state statex pull push full	'.' for current prj  '..' for current list
	# todo: unite cmd_state_of_all_projects  cmd_state_of_projects
	# todo: unite with cmd_save_all_project_at_local
	# todo: unite with cmd_pull_all_projects
	# todo: make sync
	local cmd="$1"
	local obj="$2" # prj_or_list
	trace_prj "obj:\t$obj"
	#[ "$cmd" == "" ] && echo "${red}[cmd_project_sync] Param 'sync_type' is missed ${norm}" 
	# [cmd_project_sync] 
	[ "$cmd" == "" ] && \
		echo -e "Syntax:\t\t\t\t${green}prs${norm} ${yellow}<sync_type> .|<prj>|..|<list>${norm}" && \
		echo -e "\t${yellow}sync_type${norm}:\t\tstate_local | state_remote | pull | push | full" && \
		echo -e "\t${yellow}.|<prj>|..|<list>${norm}:\tcurrent project | name of project | current list | name of list" && \
		return

	[ "$obj" == "" ] && obj="."
	local objtype="project"
	[[ "$obj" != "." && "$obj" != ".." ]] && objtype=$(get_project_or_list)
	[ "$obj" == "." ] && obj=$(get_current_project)
	[ "$obj" == ".." ] && obj=$(get_current_set)
	trace_prj "obj:\t$obj"
	trace_prj "objtype:\t$objtype"
	return

	[ "$objtype" == "" ]
	#cmd_state_of_projects(){	# psp[x] .|<prj>|<list> 

	[ "$prj_list" == "" ] && prj_list=default
	
	[[ "$prj_list" == "default" ]] && prj_list=$(get_current_set)
	trace_prj "prj_list:\t\t$prj_list"
	#[[ "$remote_mode" == "" ]] && -e "${red}[lib-prj.:projects_state] 'remote_mode' param is not defined !${norm} " && return

	echo
	for prj in $(cat $UTILS_PRJ_CONFIGS/$UTILS_PRJ_THE_HOST/$prj_list.list | sed -e /^$/d | tr -d '\r' | sort); do 
		prj=`echo $prj` # normalize
		prj_file=`echo $UTILS_PRJ_CONFIGS/$UTILS_PRJ_THE_HOST/$prj`
		if [[ ! -f "$prj_file" ]]; then
			#echo prj: $UTILS_PRJ_CONFIGS/$UTILS_PRJ_THE_HOST/$prj
			#cat $UTILS_PRJ_CONFIGS/$UTILS_PRJ_THE_HOST/$prj
			echo -e "${red} Project file '$prj_file' not found !${norm} "
			continue
		  fi

		#prj_file=`eval echo $prj_file` # cut <CR> 
		trace_prj "prj_file:\t\t$prj_file" 

		prj_path=`sed -E -n 's/^path=([^#]+).*/\1/p' "$prj_file" | tr -d '\r'` 
		prj_path=`eval echo $prj_path` # for osx replace ~ to $HOME (and cut <CR>?)
		trace_prj "prj_path:\t\t$prj_path"
		[[ ! -d "$prj_path" ]] && echo -e "${red} Project path '$prj_path' not found !${norm} " && continue
		(
		eval cd "$prj_path"
		changes=$(gis | wc -l) 
		trace_prj "changes:\t\t$changes"
		#	echo -e "${grey}$prj: $prj_path${norm}"
		#  else

		echo -e "${grey_back} $prj_list  $prj \t $prj_path ${norm}"
		[ $changes -ne 0 ] && git status -s --untracked-files

		local sync_remote_status=$(get_sync_status $remote_mode "notice" no_TRACE)
		trace_prj "sync_remote_status:\t$sync_remote_status"
		#[[ "$changes" != "0" || "$sync_remote_status" != "ok" ]] && 
		echo
		)
	  done
	}

# data sync =============================
cmd_save_one_projects(){	# psave <prj>|. [<msg>]
	# psave <prj> <msg> # save prj-repo (add/commit/push)
	# todo: . <msg>
	# to TRACE - 'bp; TRACE=1; psave kj'
	local prj=$1
	local msg=$2
	
	[ "$prj" == "" ] && echo "psave <prj>|. [<msg>]" && return 
	trace_prj "prj:\t\t$prj"
	# echo UTILS_PRJ_HOME: $UTILS_PRJ_HOME
	# echo UTILS_PRJ_THE_HOST: $UTILS_PRJ_THE_HOST
	#default_repos=$(get_current_set) 	# echo default_repos: $default_repos  # get default repos  

	if [[ "$prj" == "." ]]; then 
		curr_path=`eval echo $(pwd)` #; echo cur_path:$curr_path
		prj_name=$(get_project_name $curr_path)
		trace_prj "prj_name:\t$prj_name"
		[[ "$prj_name" == "" ]] && echo "[SAVE PROJECT] project name is missed  and  not found by 'current path' in $UTILS_PRJ_CONFIGS/$UTILS_PRJ_THE_HOST !" && return
		# save prj
		echo "SAVING $prj_name: $curr_path"
		gok "$msg"
		return
	  fi

	# find prj file by current path
	local prj_path=$(get_project_path $prj)
	trace_prj "prj_path:\t$prj_path" #"$UTILS_PRJ_CONFIGS/$UTILS_PRJ_THE_HOST" 
	[ "$prj_path" == "" ] && echo -e "${red}[SAVE PROJECT] prj_path not found !${norm}" && return
	local prj_path_norm=`eval echo $prj_path`
	trace_prj "prj_path_norm:\t$prj_path_norm"
	#[[ "$prj_path_norm" == "" ]] && echo -e "${red}[SAVE PROJECT] project file '$UTILS_PRJ_CONFIGS/$UTILS_PRJ_THE_HOST/$prj' not found !${norm}" && return
	[[ ! -d "$prj_path_norm" ]] && echo -e "${red}[SAVE PROJECT] project path '$prj_path_norm' not found !${norm}" && return
	# TODO: get prj vcs_type (svn, git)
	# TODO: get prj remote

	( # to return current path
	echo -e "prj_path:\t$prj_path"
	eval cd "$prj_path"
	gok "$msg" 
	)
	# TODO: test uncommited (untracked, changed, deleted, staged)
	}
cmd_save_all_projects(){	# psavall <list>|. [<msg>]
	# psavall <msg> <list>  # save every prj in list (add/commit/push)
	trace_prj=$1
	msg=$2

	trace_prj "UTILS_PRJ_HOME:\t\t$UTILS_PRJ_HOME"
	trace_prj "UTILS_PRJ_THE_HOST:\t$UTILS_PRJ_THE_HOST"

	[[ "$trace_prj" == "." ]] && trace_prj="" # trik to save default
	[[ "$trace_prj" == "" ]] && trace_prj=$(get_current_set)
	trace_prj "prj_list:\t\t$prj_list" # get default repos list

	echo
	for prj in $(cat $UTILS_PRJ_CONFIGS/$UTILS_PRJ_THE_HOST/$trace_prj.list | tr -d '\r' | sort); do 
		prj_path=`sed -E -n 's/^path=([^#]+).*/\1/p' $UTILS_PRJ_CONFIGS/$UTILS_PRJ_THE_HOST/$prj | tr -d '\r'` # sed -E -n 's/^path=([^#]+)/\1/p' /Users/a.bysov/prj/utils-vcs/.cfg/ok/ue
		(
		eval cd "$prj_path" # for osx replace ~ to $HOME
		changes=$(gis | wc -l)	# echo changes: $changes
		echo -e "${grey_back} $trace_prj  $prj \t $prj_path${norm}"
		trace_prj "prj_path:\t\t$prj_path"
		trace_prj "changes:\t\t$changes" # 2> /dev/null 
		if [[ "$changes" == "0" ]]; then
			local sync_remote_status=$(get_sync_status remote silent no_TRACE)
			trace_prj "sync_remote_status:\t$sync_remote_status" # 2> /dev/null 
		  fi

		if [ "$changes" != "0" ]; then
			gok "$msg" # TODO: переделать на использование либы 
		  fi
		if [[ "$changes" == "0" && "$sync_remote_status" == "push" ]]; then
			gus
		  fi
		[[ "$sync_remote_status" != "push" && "$sync_remote_status" != "ok" ]] && show_sync_status "$status"
		echo
		)
	  done
	# TODO: test uncommited (untracked, changed, deleted, staged)
	}
cmd_save_one_project_at_local(){ # pfix <prj> <msg>
	# pfix <prj> <msg> # save prj-repo (add/commit/push)

	prj=$1
	msg=$2

	# echo UTILS_PRJ_THE_HOST: $UTILS_PRJ_THE_HOST
	#default_repos=$(get_current_set) 	# echo default_repos: $default_repos  # get default repos  

	if [[ "$prj" == "" ]]; then 
		curr_path=`eval echo $(pwd)` #; echo cur_path:$curr_path
		prj_name=$(get_project_name $curr_path) #; echo prj_name: $prj_name
		[[ "$prj_name" == "" ]] && echo "[SAVE PROJECT] project name is missed  and  not found by 'current path' in $UTILS_PRJ_CONFIGS/$UTILS_PRJ_THE_HOST !" && return
		# save prj
		echo "SAVING $prj_name: $curr_path"
		gac "$msg" 
		return
	  fi

	# find prj file by current path
	prj_path=$(get_project_path $prj) #"$UTILS_PRJ_CONFIGS/$UTILS_PRJ_THE_HOST"
	[[ "$prj_path" == "" ]] && echo  "[SAVE PROJECT] project file '$UTILS_PRJ_CONFIGS/$UTILS_PRJ_THE_HOST/$prj' not found !" && return
	# TODO: get prj vcs_type (svn, git)
	# TODO: get prj remote
	( # to return current path
	echo "$prj: $prj_path"
	eval cd "$prj_path"
	gac "$msg" 
	)

	# TODO: test uncommited (untracked, changed, deleted, staged)
	}
cmd_save_all_projects_at_local(){ # pfixall <list>|. [<msg>]
	# pfixall <prj> <msg> # add/commit
	prj_list=$1
	msg=$2

	trace_prj "UTILS_PRJ_HOME:\t$UTILS_PRJ_HOME"
	trace_prj "UTILS_PRJ_THE_HOST:\t$UTILS_PRJ_THE_HOST"

	[[ "$prj_list" == "." ]] && prj_list="" # trik to save default
	[[ "$prj_list" == "" ]] && prj_list=$(get_current_set)
	trace_prj "prj_list:\t\t$prj_list"

	for prj in $(cat $UTILS_PRJ_CONFIGS/$UTILS_PRJ_THE_HOST/$prj_list.list | tr -d '\r' | sort); do 
		prj_path=`sed -E -n 's/^path=([^#]+).*/\1/p' $UTILS_PRJ_CONFIGS/$UTILS_PRJ_THE_HOST/$prj | tr -d '\r'` # sed -E -n 's/^path=([^#]+)/\1/p' /Users/a.bysov/prj/utils-vcs/.cfg/ok/ue
		(
		eval cd "$prj_path"
		changes=$(gis | wc -l)	# echo changes: $changes
		echo -e "\n${grey_back} $prj_list  $prj \t $prj_path${norm} "
		if [ $changes -ne 0 ]; then
			gac "$msg" # TODO: переделать на использование либы 
			echo
		  fi
		#${red}none${norm}"
		)
	  done
	#echo
	}
cmd_pull_one_project(){		# pget 	<prj> 
	# pget <prj> 

	#TRACE=0
	prj=$1
	msg=$2
	#[ $TRACE == 1 ] && echo start
	[ $TRACE == 1 ] && echo -e "UTILS_PRJ_THE_HOST:\t$UTILS_PRJ_THE_HOST"

	curr_path=$(pwd) ; [ $TRACE == 1 ] && echo curr_path: $curr_path	
	if [[ "$prj" == "" ]]; then 
		curr_path=`eval echo $(pwd)` #; echo cur_path:$curr_path
		prj_name=$(get_project_name $curr_path no_TRACE) #; echo prj_name: $prj_name
		[[ "$prj_name" == "" ]] && echo "[SAVE PROJECT] project name is missed  and  not found by 'current path' in $UTILS_PRJ_CONFIGS/$UTILS_PRJ_THE_HOST !" && return
		# get prj (update)
		echo "GETTING $prj_name: $curr_path"
		gul
		return
	  fi

	# find prj file by current path
	prj_path=$(get_project_path "$prj"); [ $TRACE == 1 ] && echo prj_path: $prj_path # "$UTILS_PRJ_CONFIGS/$UTILS_PRJ_THE_HOST"
	[[ "$prj_path" == "" ]] && echo -e "${red}[PROJECT GET] Project path not found (by name: $prj) ! ${norm}" && return
	# TODO: get prj vcs_type (svn, git)
	# TODO: get prj remote
	( # to return current path
	echo "$prj: $prj_path"
	eval cd "$prj_path"
	gul "$msg" 
	)
	# TODO: test uncommited (untracked, changed, deleted, staged)
	}
cmd_pull_all_projects(){	# pgetall <list>|.
	# pgetall <list> # save every prj in list (add/commit/push)
	prj_list=$1

	# echo home: $home
	# echo UTILS_PRJ_THE_HOST: $UTILS_PRJ_THE_HOST
	[[ "$prj_list" == "." ]] && prj_list="" # trik to set default
	[[ "$prj_list" == "" ]] && prj_list=$(get_current_set)
	trace_prj "prj_list:\t\t$prj_list" # get default repos list

	for prj in $(cat $UTILS_PRJ_CONFIGS/$UTILS_PRJ_THE_HOST/$prj_list.list | tr -d '\r' | sort ); do 
		prj_path=`sed -E -n 's/^path=([^#]+).*/\1/p' $UTILS_PRJ_CONFIGS/$UTILS_PRJ_THE_HOST/$prj | tr -d '\r'` # sed -E -n 's/^path=([^#]+)/\1/p' /Users/a.bysov/prj/utils-vcs/.cfg/ok/ue
		(
		eval cd "$prj_path"
		echo -e "\n ${grey_back} $prj_list  $prj \t $prj_path ${norm}"
		changes=$(gis | wc -l) 
		trace_prj "changes:\t\t$changes" # 2> /dev/null 

		if [ $changes -eq 0  -o  "$changes" == "" ]; then
			compare_status=$(get_sync_status remote silent noTRACE)
			trace_prj "compare_status:\t$compare_status"
			[ "$compare_status" == "diverged" ] && echo -e "${red_bright}DIVERGED ! NEED TO PUSH AFTER ${norm}" # 
			if [[ "$compare_status" == "pull" || "$compare_status" == "diverged" ]]; then
				gul
				git diff --stat=200 HEAD~1 HEAD --color | sed -n '$! p' # files in last commit 
			  fi
		  else
    		  	gis
		  fi
		)
	  done
	# TODO: test uncommited (untracked, changed, deleted, staged)
	}
cmd_sync_one_project(){		# psync <prj>|. [<msg>]
	# psync <prj> <msg> # a) fix prj when need (add/commit) 2) pull when need  3) push when need

	# test 1st param - repo name
	prj=$1
	msg=$2

	# echo home: $home
	# echo UTILS_PRJ_THE_HOST: $UTILS_PRJ_THE_HOST

	if [[ "$prj" == "" ]]; then 
		curr_path=$(pwd) #; echo cur_path:$curr_path # replace 
		prj_name=$(get_project_name $curr_path) #; echo prj_name: $prj_name
		[[ "$prj_name" == "" ]] && echo "[PROJECT SYNC] project name is missed  and  not found by 'path=' in $UTILS_PRJ_CONFIGS/$UTILS_PRJ_THE_HOST !" && return
	  fi

	# TODO: get prj vcs_type (svn, git)
	# TODO: get prj remote

	( # to return current path
	echo "$prj: $prj_path"
	eval cd "$prj_path"
	echo "prj_name: $prj_name"

	# fix prj when need (add/commit) 
	#gac "$msg" 

	# pull when need  
	gul

	# push when need
	gus
	return
	)



	# TODO: test uncommited (untracked, changed, deleted, staged)
	}

cmd_project_exec(){		# pcmd <prj> <cmd>
	local prj_name="$1"
	local prj_cmd="$2"
	#[ "$TRACE" == "" ] && local TRACE=0 #$3
	
	#[[ "$prj_cmd" == "default" ]] && prj_list=$(get_current_set)
	[ "$prj_cmd" == "" ] && echo -e "[cmd_project_exec] Syntax: ${green}pcmd ${yellow}<prj> <cmd>${norm}, ex.: pcmd my_prj 'ls'" && return 
	local prj_path=$(get_project_path "$prj_name")
	[ "$prj_path" == "" ] && echo -e "${red}[cmd_project_exec] Project $prj_name not found${norm}" && return
	(
	cd "$prj_path"
	eval "$prj_cmd"
	)
	}
