#!/bin/bash

# === release notes ===
	# WARING: Don't change the file before and incuding line contains 'cmd_utils_prj_wrapper(){' because 'pupd' willn't work
	# тильда в переменной для указания в пути домашней папки- крэшит команды (cd, ls ..)
	# 	workaround: eval echo $path
	# 	re="~(.*)"; if [[ $path =~ $re ]]; then  path=${BASH_REMATCH[1]}; fi; cd $HOME$path
	# if you want edit lib-prj and trace it, you can use next cmd: 
	# 	$ UTILS_PRJ_TRACE=1; <cmd>; UTILS_PRJ_TRACE=0
	# alias change didn't take effect if you run new alias in one command with 'pupd' throuhg ';'. Run 'pupd' separatly like this:
	#	$ pupd; 
	#	$ <cmd_by_new_alias>

# === globals ===
UTILS_PRJ_TRACE=0
UTILS_PRJ_HOME=$(dirname ${BASH_SOURCE[0]})
#UTILS_PRJ_CONFIGS=`eval echo $HOME/.utils-prj` # fix '~' bug
UTILS_PRJ_THE_HOST=$(uname -n)
UTILS_PRJ_THE_OS=$(uname -s)
UTILS_PRJ_INCLUDE="utils-prj-include"
UTILS_PRJ_ALIASES="utils-prj-aliases"
case "$UTILS_PRJ_THE_OS" in
	MINGW*)
		UTILS_PRJ_SED_BACKUP="" #|MSYS*
		UTILS_PRJ_SED="sed"
		UTILS_PRJ_TIMESTAMP=`stat -c %y $HOME_UTILS_PRJ/lib-prj`
		UTILS_PRJ_ALIAS_TIMESTAMP=`stat -c %y $HOME/.utils-prj/$UTILS_PRJ_ALIASES`
		;;
	Darwin)
		UTILS_PRJ_SED_BACKUP="''"
		UTILS_PRJ_SED="gsed"
		UTILS_PRJ_TIMESTAMP=$(stat -f "%Sm" -t "%h %U %G %s" "$HOME_UTILS_PRJ/lib-prj")
		UTILS_PRJ_ALIAS_TIMESTAMP=$(stat -f "%Sm" -t "%h %U %G %s" "$HOME/.utils-prj/$UTILS_PRJ_ALIASES")
		;;
	# linux??)
		# UTILS_PRJ_SED_BACKUP=??
		# UTILS_PRJ_TIMESTAMP=??
	*)
		# fail !
  esac
alias log_print='[ "$UTILS_PRJ_TRACE" == "1" ] && echo -e '

cmd_utils_prj_wrapper(){
	local cmd_one="$1"

	local utils_prj_timestamp_current
	case "$UTILS_PRJ_THE_OS" in
		MINGW*)
			utils_prj_timestamp_current=`stat -c %y $HOME_UTILS_PRJ/lib-prj`
			utils_prj_alias_timestamp_current=`stat -c %y $HOME/.utils-prj/$UTILS_PRJ_ALIASES`
			;;
		Darwin)
			utils_prj_timestamp_current=$(stat -f "%Sm" -t "%h %U %G %s" "$HOME_UTILS_PRJ/lib-prj")
			utils_prj_alias_timestamp_current=$(stat -f "%Sm" -t "%h %U %G %s" "$HOME/.utils-prj/$UTILS_PRJ_ALIASES")
			;;
		# linux??)
			# UTILS_PRJ_TIMESTAMP=??
		*)
			# fail !
	  esac
	#echo -e "utils_prj_timestamp_current:\t$utils_prj_timestamp_current"
	#echo -e "UTILS_PRJ_TIMESTAMP:\t\t$UTILS_PRJ_TIMESTAMP"

	[ "$utils_prj_timestamp_current" != "$UTILS_PRJ_TIMESTAMP" ] && echo "Updating commands..." && source "$HOME_UTILS_PRJ/lib-prj"
	[ "$utils_prj_alias_timestamp_current" != "$UTILS_PRJ_ALIAS_TIMESTAMP" ] && echo "Updating aliases..." && source "$HOME/.utils-prj/$UTILS_PRJ_ALIASES"
	#echo "wrapper2"
	shift
	local params
	while :
	do
		#echo "arg: $1"
		case "$1" in
			#-h|--help) ;;
			-v) UTILS_PRJ_TRACE=1 ;;
			#-*) echo "invalid argument $1";;
			?*) params="$params $1" ;;
			"") break ;;
		  esac
		shift
	done
	#echo "params: $params"
	eval $cmd_one "$params" #"$@*"
	UTILS_PRJ_TRACE=0
	}

# === install ===
utils-prj-setup(){
	# обновляем файлы если уже есть
	[ ! -d ~/.utils-git ] && echo "to run commands on git repos required utils-git"
	[ ! -d ~/.utils-env ] && echo "to get messages in colored manner required utils-env"

	[ ! -d "$HOME/.utils-prj" ] && mkdir "$HOME/.utils-prj"
	[ ! -f "UTILS_PRJ_CONFIGS/$utils_include" ] && 	copy "$UTILS_PRJ_HOME/$UTILS_PRJ_INCLUDE" "UTILS_PRJ_CONFIGS/$UTILS_PRJ_INCLUDE"
	# sed REPLACE path in 'export HOME_UTILS_PRJ= ex to "/C/app/utils-prj"
	[ ! -f "UTILS_PRJ_CONFIGS/$UTILS_PRJ_ALIASES" ] && copy "$UTILS_PRJ_HOME/$UTILS_PRJ_ALIASES" "UTILS_PRJ_CONFIGS/$UTILS_PRJ_ALIASES"
	# sed UTILS_PRJ_HOME in 'include' # to include lib to shell and some commands (ex. pel, p-help)
	local bash_profile=`eval echo ~/.bash_profile` # fix ~ bug
	touch "$bash_profile"
	# [ if not found '. ~/.utils-prj/include ] && echo '. ~/.utils-prj/include' >> .bash_profile
	# echo "add to PATH?" read  [] echo "export PATH=$PATH:$UTILS_PRJ_HOME" >> $utils_include
	mkdir "$HOME/.utils-prj/$UTILS_PRJ_THE_HOST"
	[ ! -f "UTILS_PRJ_CONFIGS/$UTILS_PRJ_THE_HOST/default" ] && copy "$UTILS_PRJ_HOME/default" "UTILS_PRJ_CONFIGS/$UTILS_PRJ_THE_HOST/default"
	touch "UTILS_PRJ_CONFIGS/$UTILS_PRJ_THE_HOST/!projects"
	echo "'p-help' - print readme.adoc"
	echo "'pshow' - print current configuration (config files, project sets with projects)"
	echo "'padd my_alias' - add alias and current folder to projects list (at start - 'default')"
	echo "'plist' - review assigned aliases"
	echo "'pgo my_alias' - cmd_project_go home"
	echo "'pfix my_alias' - save project at local repository"
	echo "'psave my_alias' - save project and sync with remote repository"
	echo "'pget my_alias' - pull project from remote repository"
	}
utils-prj-uninstall(){
	# cut '. ~/.utils-prj/include' from .bash_profile
	rm "UTILS_PRJ_CONFIGS/$UTILS_PRJ_INCLUDE"
	rm "UTILS_PRJ_CONFIGS/$UTILS_PRJ_ALIASES"
	# echo remove host aliases also ?; read; 
		# rm -r -f "$HOME/.utils-prj/$UTILS_PRJ_THE_HOST"
		# cd "UTILS_PRJ_CONFIGS/.."
		# rm "UTILS_PRJ_CONFIGS"
	cd "$UTILS_PRJ_HOME"/..
	rm "$UTILS_PRJ_HOME"
	}
cmd_prj_help(){
	clear
	#less -n -r $UTILS_PRJ_HOME/readme.clr
	while IFS='' read -r line || [[ -n "$line" ]]; do
		eval "echo -e \"$line\""
	done < <(cat $UTILS_PRJ_HOME/help.clr ) #| head -n 2
	}

# === config functions ===
cmd_show_current_config(){	# pshow  green
	echo -e "${red_on_green}  Overview:  ${norm}\nutils-prj - version 1.0\nUse 'p-help' for more\n"
	echo -e "${red_on_green}  Where installed (\$UTILS_PRJ_HOME):  ${norm}\n$UTILS_PRJ_HOME/\n"
	echo -e "${red_on_green}  How inited (position in $HOME/.bash_profile):  ${norm}\n$(grep -n -A 2 '.utils-prj' ~/.bash_profile)\n"
	echo -e "${red_on_green}  Settings:  ${norm}\n$HOME/.utils-prj/$UTILS_PRJ_INCLUDE\n$HOME/.utils-prj/$UTILS_PRJ_ALIASES\n$HOME/.utils-prj/$UTILS_PRJ_THE_HOST/*"

	cmd_project_enum ..
	}

cmd_project_enum(){		# plist		[<list>]
	# plist <list>
	# echo UTILS_PRJ_THE_HOST: $UTILS_PRJ_THE_HOST
	local prj_list="$1"
	local current_set=$(get_current_set)
	# [[ "$prj_list" == "..." ]] && prj_list= 
	[[ "$prj_list" == ".." ||  "$prj_list" == "." ]] && prj_list="$current_set"
	  log_print "prj_list:\t\t$prj_list"

	[[ "$prj_list" == "" ]] && echo -e "Syntax: ${green}plist ${yellow}<list>${norm}" && return 
	#[ "$prj_list" == "" ] && prj_list="$current_set"
	local current_project=$(get_project_name "$(pwd)")
	  log_print "current_project:\t$current_project"

	if [[ "$prj_list" != "..." ]]; then
		[ ! -f "$HOME/.utils-prj/$UTILS_PRJ_THE_HOST/$prj_list.list" ] && echo -e "${red}[cmd_project_enum] Project list '$HOME/.utils-prj/$UTILS_PRJ_THE_HOST/$prj_list.list' not found !${norm}" && return
	  fi
	if [ "$current_set" == "$prj_list" ]; then
		#echo -e "\n${red_on_green}  $prj_list ${magenta_on_green}(current set)  ${norm}"
		echo -e "\n${red_on_green}  $prj_list  (current set)  ${norm}"
	  else
	  	[[ "$prj_list" != "..." ]] && echo -e "\n${red_on_green}  $prj_list  ${norm}" # ${black_on_green}
	  fi

	if [[ "$prj_list" == "..." ]]; then
		for prj_name in $(find $HOME/.utils-prj/$UTILS_PRJ_THE_HOST/. -maxdepth 1 -type f ! -name '*.list' -a ! -name default -exec basename {} \; | sort); do #  | sed -e /^$/d | tr -d '\r' | 
			#prj_name=`eval echo $prj_name` # normalize (<CR> ~)
			local path=`sed -E -n 's/^path=([^#]+).*/\1/p' $HOME/.utils-prj/$UTILS_PRJ_THE_HOST/$prj_name | tr -d '\r'`
			if [ "$current_project" == "$prj_name" ]; then
				echo -e "${green}$prj_name${norm}\t${green}$path ${grey}(current)${norm}"
			  else
				echo -e "$prj_name\t$path"
			  fi
		  done
	  else
		for prj_name in $(cat $HOME/.utils-prj/$UTILS_PRJ_THE_HOST/$prj_list.list | sed -e /^$/d | tr -d '\r' | sort); do 
			#prj_name=`eval echo $prj_name` # normalize (<CR> ~)
			local path=`sed -E -n 's/^path=([^#]+).*/\1/p' $HOME/.utils-prj/$UTILS_PRJ_THE_HOST/$prj_name | tr -d '\r'`
			if [ "$current_project" == "$prj_name" ]; then
				echo -e "${green}$prj_name${norm}\t${green}$path ${grey}(current)${norm}"
			  else
				echo -e "$prj_name\t$path"
			  fi
		  done
	  fi
	echo
	}
cmd_project_add(){		# padd		<prj> 		[<list>]
	# cmd_add_project -n=<prj> -p=<path> -t=<type> -r=<remote> -s=<set>
	local prj_name=$1
	local prj_list=$2
	local prj_path=$3

	#[[ "$prj_name" == "" ]] && echo -e "${red}[cmd_project_add] prj_name param is missed !${norm}" && return 
	[[ "$prj_name" == "" ]] && echo -e "Syntax: ${green}padd ${yellow}<prj> [<list>]${norm}" && return 
	local curr_path="${PWD/#$HOME/~}"
	[ "$prj_path" = "" ] && prj_path="$curr_path"
	log_print "prj_path:\t$prj_path"
	
	# TODO: detect repo type (git/svn/hg - .git foder / .svn folder? / ..)
	# TODO: return when curr_path not repo
	# TODO: test prj_name in list
	# TODO: detect tail CR and don't append \n
	# TODO: if file exists but absent in default list then add

	#log_print "home:\t\t$UTILS_PRJ_HOME"; log_print "UTILS_PRJ_THE_HOST:\t\t$UTILS_PRJ_THE_HOST"

	if [[ "$prj_list" == "" ]]; then
		prj_list_default=$(get_current_set)
		log_print "default_list:\t$prj_list_default"
		[ "$prj_list_default" == "" ] && echo -e "${red}[cmd_project_add] prj_list_default not found !${norm}" && return
		prj_list="$prj_list_default.list"
	  else
	  	prj_list="$prj_list.list"
	  fi; log_print "prj_list:\t$prj_list"
		
	prj_file="$HOME/.utils-prj/$UTILS_PRJ_THE_HOST/$prj_name"; log_print "prj_file:\t$prj_file"
	[[ -f $prj_file ]] && echo -e "${red}[cmd_project_add] Project already exists${norm}" && return

	echo "path=$prj_path" 	> $prj_file
	echo "type=git" 	>> $prj_file
	echo "remote=" 		>> $prj_file

	echo -e "$prj_name" >> "$HOME/.utils-prj/$UTILS_PRJ_THE_HOST/$prj_list" # ? test to exists?
	echo -e "[cmd_project_add] Project ${green}$prj_name - $prj_path${norm} added to ${green}$prj_list${norm}" # ? test to exists?
	# shift loop
	# if $prj_name == "" then folder
	# if $path == "" then pwd
	# if $type == "" then git
	# if $remote == "" then current
	# if $set == "" then default
	}
cmd_project_delete(){		# pdel		<prj>
	#-n=<prj> -p=<path> -s=<set>
	# alias pcfg='cmd_cfg' ???
	# pcfg <option>=<value>
	# pcfg --switch_default_prj_list=<prj_list>
	# pcfg --default_project=<prj>

	# shift loop
	# if $path == "" then pwd
	# if $prj == "" then folder
	# if $set == "" then default

	# if path == $path then rm
	local prj_name="$1"
	[[ "$prj_name" == "" ]] && echo -e "Syntax: ${green}pdel ${yellow}<prj>${norm}" && return 
	#[ "$prj_name" == "" ] && prj_name=$(get_project_name "$(pwd)")
	#[[ "$prj_name" == "" ]] && echo -e "${red}[cmd_project_delete] prj_name param is missed !${norm}" && return 
	[[ ! -f "$HOME/.utils-prj/$UTILS_PRJ_THE_HOST/$prj_name" ]] && echo -e "[cmd_project_delete] Project '${red}$HOME/.utils-prj/$UTILS_PRJ_THE_HOST/$prj_name${norm}' not found !" && return 
	prj_path=`sed -E -n 's/^path=([^#]+).*/\1/p' $HOME/.utils-prj/$UTILS_PRJ_THE_HOST/$prj_name | tr -d '\r'`
	#prj_type=`sed -E -n 's/^type=([^#]+).*/\1/p' $UTILS_ PRJ_CONFIGS/$UTILS_PRJ_THE_HOST/$prj_name | tr -d '\r'`
	#prj_remote=`sed -E -n 's/^remote=([^#]+).*/\1/p' $HOME/.utils-prj/$UTILS_PRJ_THE_HOST/$prj_name | tr -d '\r'`
	rm "$HOME/.utils-prj/$UTILS_PRJ_THE_HOST/$prj_name" || return
	local current_set="$(get_current_set).list"
	gsed -i -E "/^$prj_name$/d" "$HOME/.utils-prj/$UTILS_PRJ_THE_HOST/$current_set" && echo -e "[cmd_project_delete] Project ${yellow}$prj_name - $prj_path${norm} is deleted from ${yellow}$current_set${norm}" 
	}
cmd_project_move(){		# pmove		<prj>|. 	[<list>]
	# if list is skipped and prj_name is same 					-> update prj path
	# if list is skipped and prj_name is different from stored (find by path) 	-> upd name of prj (name and link in list)
	# if prj_name is same and list is different 					-> cut prj from current list and paste to pointed list

	local prj_name="$1"
	local prj_list="$2"

	[[ "$prj_name" == "" ]] && echo -e "Syntax: ${green}pmove ${yellow}<prj> [<list>]${norm}" && return 
	#[[ "$prj_name" == "" ]] && echo -e "${red}[PROJECT MOVE] Project name is missed !${norm}" && return

	#new_path=$(pwd) #; echo new_path: $new_path
	local curr_path="${PWD/#$HOME/~}" # replace $HOME to ~

	# TODO: detect repo type (git/svn/hg - .git foder / .svn folder? / ..) and return if new_path not a repo 

	if [ "$prj_list" == "" ]; then
		local prj_list="$(get_current_set).list"
		local project_name=$(get_project_name); log_print "project_name:\t$project_name"
		[ "$project_name" == "" ] && echo -e "${red}Project not found by '$curr_path'${norm}" && return
		if [ "$project_name" == "$prj_name" ]; then
			# update prj path
			gsed -i -E "s/^(path=)(.*)/\1${curr_path//\//\\/}/g" "$HOME/.utils-prj/$UTILS_PRJ_THE_HOST/$prj_name" || return #  replace home path
		  else
			# upd name of prj (name and link in list)
			[ -f "$HOME/.utils-prj/$UTILS_PRJ_THE_HOST/$prj_name" ] && echo -e "${red}Project '$HOME/.utils-prj/$UTILS_PRJ_THE_HOST/$prj_name' already exist ${norm}"
			local found=$(grep "^$project_name$" "$HOME/.utils-prj/$UTILS_PRJ_THE_HOST/$prj_list")
			log_print "found:\t$found"
			[ "$found" != "$project_name" ] && echo -e "${red}Project '$HOME/.utils-prj/$UTILS_PRJ_THE_HOST/$prj_name' not found in '$HOME/.utils-prj/$UTILS_PRJ_THE_HOST/$prj_list' ${norm}" && return
			mv "$HOME/.utils-prj/$UTILS_PRJ_THE_HOST/$project_name" "$HOME/.utils-prj/$UTILS_PRJ_THE_HOST/$prj_name" || return
			gsed -i -E "s/^$project_name$/$prj_name/g" "$HOME/.utils-prj/$UTILS_PRJ_THE_HOST/$prj_list" || return
		  fi
	  else
		# cut prj from current list and paste to pointed list
		[ "$prj_name" == "." ] && prj_name=$(get_project_name); log_print "prj_name:\t$prj_name"
		local current_set=$(get_current_set); log_print "current_set:\t$current_set"
		[[ ! -f "$HOME/.utils-prj/$UTILS_PRJ_THE_HOST/$prj_list.list" ]] && echo -e "${red}[cmd_project_move] Project list '$HOME/.utils-prj/$UTILS_PRJ_THE_HOST/$prj_list.list' not found !${norm}" && return
		[ "$prj_list" == "$current_set" ] &&echo -e "${red}[cmd_project_move] Target project list '$prj_list.list' can't be current !${norm}" && return
		echo "$prj_name" >> "$HOME/.utils-prj/$UTILS_PRJ_THE_HOST/$prj_list.list"
		echo -e "[cmd_project_move] Project ${green}$prj_name${norm} added to ${green}'$HOME/.utils-prj/$UTILS_PRJ_THE_HOST/$prj_list.list'${norm}" 
		gsed -i -E "/^$prj_name$/d" "$HOME/.utils-prj/$UTILS_PRJ_THE_HOST/$current_set.list" || return
		echo -e "[cmd_project_move] Project ${yellow}$prj_name${norm} cut from ${yellow}'$HOME/.utils-prj/$UTILS_PRJ_THE_HOST/$current_set.list'${norm}" 
		[ "$(grep "^$prj_name$" "$HOME/.utils-prj/$UTILS_PRJ_THE_HOST/$current_set.list")" != "" ] && echo -e "${red}Project '$prj_name' still found in '$prj_list' ${norm}" && return
	  fi
	cmd_project_enum # plist
	}
cmd_project_rename(){		# pren 		<prj>
	# pren <prj> [<list>]  - rename prj name (alias) (find prj by curr_path)
	# pren -n=<prj> -p=<path> -t=<type> -r=<remote> -s=<set>

	cmd_project_enum . # plist
	#UTILS_PRJ_TRACE=0
	new_prj_name=$1
	[[ "$new_prj_name" == "" ]] && echo -e "${red}[cmd_project_rename] Project name not found !${norm}" && return
	#list=$2

	#new_path=$(pwd) #; echo new_path: $new_path
	curr_path="${PWD/#$HOME/~}" # replace $HOME to ~

	# TODO: detect repo type (git/svn/hg - .git foder / .svn folder? / ..) and return if new_path not a repo 

	#log_print "UTILS_PRJ_HOME:\t$UTILS_PRJ_HOME" 
	#log_print "UTILS_PRJ_THE_HOST: $UTILS_PRJ_THE_HOST"

	if [[ "$list" == "" ]]; then
		prj_list=$(get_current_set).list 
	  else
	  	prj_list="$list.list"
	  fi
	log_print"prj_list:\t$prj_list"
	# TODO: test prj in list
	#return
	curr_path=`eval echo $curr_path` # replace '~'' -> $HOME

	curr_prj_name=$(get_project_name $curr_path $UTILS_PRJ_TRACE) ; log_print "curr_prj_name:\t$curr_prj_name"	 #old prj name
	[[ "$curr_prj_name" == "" ]] && echo -e "${red}[cmd_project_rename] Project file not found !${norm}" && return
	  #prj_path=`sed -E -n 's/^path=([^#]+).*/\1/p' $HOME/.utils-prj/$UTILS_PRJ_THE_HOST/$new_prj_name | tr -d '\r'` #; echo curr_path: $prj_path
	#echo sed -i "s/^$curr_prj_name\$/$new_prj_name/g" "$HOME/.utils-prj/$UTILS_PRJ_THE_HOST/$prj_list" ; return
	mv "$HOME/.utils-prj/$UTILS_PRJ_THE_HOST/$curr_prj_name" "$HOME/.utils-prj/$UTILS_PRJ_THE_HOST/$new_prj_name" || return

	gsed -i -E "s/^$curr_prj_name\$/$new_prj_name/g" "$HOME/.utils-prj/$UTILS_PRJ_THE_HOST/$prj_list" || return 
	
	#echo "path=$new_path" 	>  $prj_path
	#echo "type=git" 	>> $prj_file
	#echo "remote=" 		>> $prj_file

	cmd_project_enum .

	# TODO: if file exists but absent in default list then add

	# shift loop
	# if $new_prj_name == "" then folder
	# if $path == "" then pwd
	# if $type == "" then git
	# if $remote == "" then current
	# if $set == "" then default
	}

cmd_set_enum(){			# psets
	#echo -e "\n${grey_back}          project sets          ${norm}"

	local find_path="find" # linux/osx
	[[ "$TERM" == "cygwin" ]] && find_path="$(cygpath-m "$EXEPATH")/usr/bin/find" # in windows $EXEPATH ex. C:\app\git - std env by git bash
	log_print "find_path:\t$find_path [cmd_set_enum]" 1>&2
	local set_default=$(get_current_set)
	(
	cd "$HOME/.utils-prj/$UTILS_PRJ_THE_HOST"
	local prj_list
	for prj_list in $($find_path . -maxdepth 1 -type f -name "*.list" -exec  basename "{}" ';' ); do
		#prj_list=`echo $prj_list` #normalize (cut <CR>)
		#path=`sed -E -n 's/^path=([^#]+).*/\1/p' $HOME/.utils-prj/$UTILS_PRJ_THE_HOST/$prj_list | tr -d '\r'` 
		# prj_list=${prj_list:2}
		prj_list="${prj_list/.list/}"
		[ "$prj_list" == "$set_default" ] && prj_list="${green}$prj_list ${grey}(current)${norm}"
		echo -e "$prj_list"
		#cmd_enum_projects "$prj_list"
	  done
	)
	echo
	}
cmd_set_add(){			# psetadd	<set>
	local set_name="$1"
	[[ "$set_name" == "" ]] && echo -e "${red}[cmd_set_add] set_name param is missed !${norm}" && return 
	[[ -f "$HOME/.utils-prj/$UTILS_PRJ_THE_HOST/$set_name.list" ]] && echo -e "[cmd_set_add] Project list '${red}$HOME/.utils-prj/$UTILS_PRJ_THE_HOST/$set_name/$set_name.list${norm}' already exists !" && return 
	touch "$HOME/.utils-prj/$UTILS_PRJ_THE_HOST/$set_name.list"
	[ -f "$HOME/.utils-prj/$UTILS_PRJ_THE_HOST/$set_name.list" ] && echo -e "[cmd_set_add] Project list '${green}$HOME/.utils-prj/$UTILS_PRJ_THE_HOST/$set_name.list${norm}' is added" 
	}
cmd_set_delete(){		# psetdel	<set>
	local set_name="$1"
	[[ "$set_name" == "" ]] && echo -e "${red}[cmd_set_delete] set_name param is missed !${norm}" && return 
	[[ "$set_name" == "$(get_current_set)" ]] && echo -e "${red}[cmd_set_delete] You can't delete default list !${norm}" && return 
	[[ ! -f "$HOME/.utils-prj/$UTILS_PRJ_THE_HOST/$set_name.list" ]] && echo -e "[cmd_set_delete] Project list '${red}$HOME/.utils-prj/$UTILS_PRJ_THE_HOST/$set_name.list${norm}' not found !" && return 
	local prj_name
	for prj_name in $(cat $HOME/.utils-prj/$UTILS_PRJ_THE_HOST/$set_name.list | sed -e /^$/d | tr -d '\r' | sort); do 
		prj_name=`eval echo $prj_name`; log_print "prj_name:\t$prj_name" # normalize (<CR> ~)
		prj_path=`sed -E -n 's/^path=([^#]+).*/\1/p' $HOME/.utils-prj/$UTILS_PRJ_THE_HOST/$prj_name | tr -d '\r'`
		#prj_type=`sed -E -n 's/^type=([^#]+).*/\1/p' $UTILS_ PRJ_CONFIGS/$UTILS_PRJ_THE_HOST/$prj_name | tr -d '\r'`
		#prj_remote=`sed -E -n 's/^remote=([^#]+).*/\1/p' $HOME/.utils-prj/$UTILS_PRJ_THE_HOST/$prj_name | tr -d '\r'`
		# echo "delete alias $prj_name:\t$prj_path"
		[ ! -f "$HOME/.utils-prj/$UTILS_PRJ_THE_HOST/$prj_name" ] && echo -e "[cmd_set_delete] Project ${red}$HOME/.utils-prj/$UTILS_PRJ_THE_HOST/$prj_name${norm} not found " && continue
		rm "$HOME/.utils-prj/$UTILS_PRJ_THE_HOST/$prj_name" && echo -e "[cmd_set_delete] Project ${yellow}$prj_name${norm} for ${yellow}$prj_path${norm} is deleted" 
		# -f  ignore non-existent files, never prompt
		# -r  remove directories and their contents recursively
		# -v  explain what is being done
		# -i  prompt you on every deletion.
	  done
	rm "$HOME/.utils-prj/$UTILS_PRJ_THE_HOST/$set_name.list" && echo -e "[cmd_set_delete] Project list ${yellow}$HOME/.utils-prj/$UTILS_PRJ_THE_HOST/$set_name.list${norm} is deleted" 
	}
cmd_set_rename(){		# psetren
	# verify or define by path
	# rename file
	# replace if default
	local set_name="$1"
	local extra="$2"
	[[ "$extra" != "" ]] && echo -e "${red}[cmd_set_rename] extra param's is not valid !${norm}" && return 
	[[ "$set_name" == "" ]] && echo -e "${red}[cmd_set_rename] set_name param is missed !${norm}" && return 
	local set_name_current="$(get_current_set)"; log_print "set_name_current:\t$set_name_current" # normalize (<CR> ~)
	[[ "$set_name_current" == "" ]] && echo -e "${red}[cmd_set_rename] Project list '$set_name' not found !${norm}" && return 
	[[ ! -f "$HOME/.utils-prj/$UTILS_PRJ_THE_HOST/$set_name_current.list" ]] && echo -e "${red}[cmd_set_rename] Project list ${red}$HOME/.utils-prj/$UTILS_PRJ_THE_HOST/$set_name_current.listnot found !${norm}" && return 
	[ -f "$HOME/.utils-prj/$UTILS_PRJ_THE_HOST/$set_name.list" ] && echo -e "${red}[cmd_set_rename] Project list ${red}$HOME/.utils-prj/$UTILS_PRJ_THE_HOST/$set_name.list already exist !${norm}" && return 
	eval mv "'$HOME/.utils-prj/$UTILS_PRJ_THE_HOST/$set_name_current.list'" "'$HOME/.utils-prj/$UTILS_PRJ_THE_HOST/$set_name.list'" || return
	$UTILS_PRJ_SED -i -E "s/^(default_list=)(.*)/\1$set_name/g" "$HOME/.utils-prj/$UTILS_PRJ_THE_HOST/default" && echo -e "[cmd_set_rename] Current project list now is ${green}$set_name${norm}" 
	}
cmd_set_switch(){		# psetsw	<list>|.  			# set as default
	local set_name="$1"
	[ "$set_name" == "" ] && echo -e "${red}[cmd_set_switch] set_name param is missed !${norm}" && return 
	[ ! -f "$HOME/.utils-prj/$UTILS_PRJ_THE_HOST/$set_name.list" ] && echo -e "${red}[cmd_set_switch] Project list ${red}$HOME/.utils-prj/$UTILS_PRJ_THE_HOST/$set_name.list not found !${norm}" && cmd_set_enum && return 
	gsed -i -E "s/^(default_list=)(.*)/\1$set_name/g" "$HOME/.utils-prj/$UTILS_PRJ_THE_HOST/default" && echo -e "[cmd_set_switch] Current project list is ${green}$set_name${norm} now"
	}

# == data sync ===
cmd_project_action(){		# prs 		<cmd> <obj> [<msg>]
	# sync_type: 	local remote pull push full
	# obj:		.|..|<prj>|<list> 	'.' for current prj  '..' for current list
	#cmd_state_of_projects(){	# psp[x] .|<prj>|<list> 
	# todo: unite cmd_state_of_all_projects  cmd_state_of_projects
	# todo: unite with cmd_save_all_project_at_local
	# todo: unite with cmd_pull_all_projects
	# todo: make sync
	local cmd="$1"
	local obj="$2" # prj_or_list
	local msg="$3"
	log_print "cmd:\t\t$cmd"
	log_print "obj:\t\t$obj"
	#[ "$cmd" == "" ] && echo "${red}[cmd_project_action] Param 'sync_type' is missed ${norm}" 
	# [cmd_project_action]  "$cmd" == "" || !  <sync_type>
	[[ "$obj" == "" || ! ("$cmd" == "local" || "$cmd" == "remote" || "$cmd" == "fix" || "$cmd" == "pull" || "$cmd" == "push" || "$cmd" == "full") ]] && \
		echo -e "Syntax: ${green}<command>${norm} ${yellow} <object> [<msg>]${norm}" && \
		echo -e "\t\t${green}<command>${norm}\tdefault aliases are - pst[x], pstate[x], pfix[all], pget[all], psave[all], psync[all]" && \
		#echo -e "\t${yellow}<sync_type>${norm}:\t\tlocal | remote | fix | pull | push | full" && \
		echo -e "\t\t${yellow}<object>${norm}\t'.' means current project | name of project | '..' means current list | name of list" && \
		echo -e "\t\t${yellow}<msg>]${norm}\t\tfor commit" && \
		return

	#[ "$obj" == "" ] && obj="."
	#local objtype="project"
	[[ "$obj" != "." && "$obj" != ".." ]] && objtype=$(get_object_type $obj NO_UTILS_PRJ_TRACE) # 
	local obj_orig="$obj"
	[ "$obj" == "." ] && obj=$(get_project_name "$(pwd)") && objtype="project"
	[ "$obj" == ".." ] && obj=$(get_current_set) && objtype="set"

	log_print "objtype:\t$objtype"
	log_print "obj(2):\t\t$obj"
	[ "$objtype" == "" ] && echo -e "${red}[cmd_project_action] Object type not found for '$obj' !${norm}" && return
	[ "$obj" == "" ] && echo "[cmd_project_action] $objtype not found by 'current path' in $HOME/.utils-prj/$UTILS_PRJ_THE_HOST !" && return
	# todo: multiple list for one prj
	#[[ ! -d "$prj_path_norm" ]] && echo -e "${red}[SAVE PROJECT] project path '$prj_path_norm' not found !${norm}" && return

	local prj_path
	if [ "$objtype" == "project" ]; then
		echo
		#if [ "$cmd" == "local" ]; then
		if [ "$obj_orig" == "." ]; then 
			prj_path=`eval echo $(pwd)`
		  else
			prj_path=$(get_project_path $obj) #"$HOME/.utils-prj/$UTILS_PRJ_THE_HOST"    NO_UTILS_PRJ_TRACE
		  fi
		[ "$prj_path" != "" ] && cmd_project_sync "$obj" "$prj_path" "$cmd" "$msg"
		return
		#  fi
	  fi
	if [ "$objtype" == "set" ]; then
		#if [ "$cmd" == "local" ]; then
		#(current)
		local tab="        " # mingw didn't background tabs
		echo -e "\n${black_on_green}$tab$tab${red_on_green}$obj ${magenta_on_green}$tab$tab${norm}\n"

		for prj_name in $(cat $HOME/.utils-prj/$UTILS_PRJ_THE_HOST/$obj.list | sed -e /^$/d | tr -d '\r' | sort); do 
			#prj_name=`echo $prj_name` # normalize
			log_print "prj_name:\t$prj_name"
			prj_path=$(get_project_path "$prj_name") #"$HOME/.utils-prj/$UTILS_PRJ_THE_HOST"    dont_UTILS_PRJ_TRACE NO_UTILS_PRJ_TRACE
			[ "$prj_path" == "" ] && continue
			log_print "prj_path:\t$prj_path"
			cmd_project_sync "$prj_name" "$prj_path" "$cmd" "$msg" || return #$prj_path  [ "$prj_path" != "" ] && 
		  done
	  fi
	}
cmd_project_sync(){		# 		<prj> <path> <cmd> <msg>
	local prj_name="$1"
	local prj_path="$2"
	local cmd="$3"
	local msg="$4"
	#local list="$5" 
	log_print "prj_name:\t[cmd_project_sync] $prj_name"
	log_print "prj_path:\t[cmd_project_sync] $prj_path"
	log_print "cmd/msg:\t[cmd_project_sync] $cmd/$msg"

	[ ! -d "$prj_path" ] && echo -e "${red}[cmd_project_sync] Project home path '$prj_path' not found !${norm} " && return
	( # to return current path
	# TODO: get prj vcs_type (svn, git)
	#echo -e "${grey_back} $prj_list  $prj \t $prj_path ${norm}"
	echo -e -n "${grey_back} $prj_name  -  $prj_path ${norm}"  
	eval cd "$prj_path"

	#local gis=$(git status -s --untracked-files)
	local changes=`echo $(git status -s --untracked-files | wc -l)`
	log_print "changes:\t$changes"
	case "$cmd" in
		"local"|"remote") # st[x]
			# state
			echo
			git status -s --untracked-files # "$*" - mask  echo "$gis" #
			#echo -e -n "Ask ${yellow}$cmd${norm} for last commit .. "  #[ "$remote_mode" = "remote" ] && 
			local sync_status=$(get_sync_status "$cmd" notice) # notice/silent NO_UTILS_PRJ_TRACE
			#[ "$sync_status" == "ok" ] && echo -e "${green}same${norm}"
			#[[ "$sync_status" = "remote" && "$sync_status" == "ok" ]] && echo -e "${green}same${norm}"
			log_print "sync_status:\t$sync_status"
			# [ "$compare_status" == "diverged" ] && echo -e "${red_bright}DIVERGED ! NEED TO PUSH AFTER ${norm}" # 
	  		;;
		"fix") # pfix
			[ "$changes" != "0" ] && echo -e "\n${red}FIXING${norm}" && git status -s --untracked-files && cmd_git_append_and_commit "$msg" && return
			echo -e "${yellow}Changes not found ${norm}" 
			;;
		"pull") # pget
			local LOCAL1=$(git rev-parse HEAD)
			if [ "$changes" == "0" ]; then
				echo -e "\n${red}PULL${norm} $prj_name: $prj_path" 

				git pull --stat --no-rebase #--all --quiet -vv 
					# -vv   list out your local branches with more information including what each branch is tracking and if your local branch is ahead, behind or both.
				local LOCAL2=$(git rev-parse HEAD)
				#echo LOCAL1: $LOCAL1 1>&2
				#echo LOCAL2: $LOCAL2 1>&2
				if [ "$LOCAL1" == "$LOCAL2" ]; then
					echo -e "${yellow}Changes not found ${norm}" 
				#	git diff HEAD~1 HEAD --stat=200 --color | sed -n '$! p' || return
				  fi
			  else
				echo
				git diff --stat=200 --color | sed -n '$! p' || return
				echo -e -n "\n${red}FETCH${norm} $prj_name: $prj_path" 
				git fetch || return # && git diff remote ??
				local LOCAL2=$(git rev-parse HEAD)
				#echo LOCAL1: $LOCAL1 1>&2
				#echo LOCAL2: $LOCAL2 1>&2
				if [ "$LOCAL1" == "$LOCAL2" ]; then
					echo -e -n "\n${yellow}Remote not changed${norm}" 
				#	git diff HEAD~1 HEAD --stat=200 --color | sed -n '$! p' || return
				  else
				  	echo -e "\n${red_blink}NEEDS_COMMIT${norm}" 
				  fi
			  fi
			#echo
			;;
		"push") # psave
			if [ "$changes" != "0" ] ; then
				echo 
				git status -s --untracked-files 
				echo 
				cmd_git_append_and_commit "$msg" 
				echo 
				# git config --global pull.rebase false
				# git config pull.rebase false
				# rebase = false
				# git push --quiet # cmd_git_push 
			  else
				echo -e "\n${yellow}Local changes not found ${norm}" 
				#return #&& echo -e "${red}FIXING${norm}" 
			  fi
			#git remote | xargs -L1 git push --all --quiet -u
		  	cmd_git_push all

			#echo -e "${red}PUSHING${norm}"
			#cmd_git_commit_and_push "$msg"
			;;
		"full") # psync
			[ "$changes" != "0" ] && cmd_git_append_and_commi "$msg" && echo # fix prj when need (add/commit) 

			#echo -n "Ask remote for last commit .. " 
			local sync_status=$(get_sync_status remote notice) # notice/silent NO_UTILS_PRJ_TRACE  ask for 'need to pull'
			log_print "sync_status:\t$sync_status"
			#sync_status=`eval echo $sync_status`
			[[ "$sync_status" == "pull" || "$sync_status" == "diverged" ]] && git pull # pull when need
			[[ "$sync_status" == "push" || "$sync_status" == "diverged" ]] && git remote | xargs -L1 git push --all --quiet -u #git push # push when need
			;;
		*)
			echo -e "${red}[cmd_project_sync] Project command '$cmd' not found !${norm} " && return
	  esac
	)
	echo
	}

# === navigate and exec ===
cmd_project_go(){		# pgo 	<prj> [<list>?] # dubl aliases?
	# pgo <project> 
	#UTILS_PRJ_TRACE=0
	[ $SHLVL -gt 1 ] && echo "[cmd_project_go] Subshell can't change path after return ! CORRECT USE: '. pgo <project>'" 1>&2 && return
	#if expr match $parent $(which vim) > /dev/null

	project="$1" # test 1st param - prj name
	[[ "$project" == "" ]] && echo -e "${red}[cmd_project_go] project name is missed !${norm}"

	#log_print "UTILS_PRJ_HOME:\t$UTILS_PRJ_HOME"
	#log_print "UTILS_PRJ_THE_HOST: $UTILS_PRJ_THE_HOST"
		# repos=$1; repos=$(get_current_set $repos) # echo repos: $repos
	#echo path: "$HOME/.utils-prj/$UTILS_PRJ_THE_HOST" 
	#get_project_name_verified "$HOME/.utils-prj/$UTILS_PRJ_THE_HOST" $project
	prj_path=$(get_project_path $project) #_verified
	log_print "prj_path:\t$prj_path" # "$HOME/.utils-prj/$UTILS_PRJ_THE_HOST" 
	[[ "$prj_path" == "" ]] && echo -e "${yellow}[cmd_project_go] project ${red}'$log_print'${yellow} not found !${norm}" && return
	# extract path of repo
	#project_path="$(sed -E -n 's/^path=([^#]*)/\1/p' $HOME/.utils-prj/$UTILS_PRJ_THE_HOST/$prj_repo | tr -d '\r')" 
	#log_print "project_path:\t$project_path"

	echo "go to: $prj_path"
	# ??TODO: test $path exists
	eval cd "$prj_path"
	[ "$ConEmuPID" != "" ] && $ConEmuBaseDir/ConEmuC -GuiMacro Rename 0 "${PWD##*/}" 1> /dev/null
	[ "$TERM_PROGRAM" == "Apple_Terminal" ] && echo -ne "\033]0;${PWD##*/}\007"
	}
cmd_project_exec(){		# pcmd <prj> <cmd>
	local prj_name="$1"
	local prj_cmd="$2"
	#[ "$UTILS_PRJ_TRACE" == "" ] && local UTILS_PRJ_TRACE=0 #$3
	
	#[[ "$prj_cmd" == "default" ]] && prj_list=$(get_current_set)
	[ "$prj_cmd" == "" ] && echo -e "[cmd_project_exec] Syntax: ${green}pcmd ${yellow}<prj> <cmd>${norm}, ex.: pcmd my_prj 'ls'" && return 
	local prj_path=$(get_project_path "$prj_name" NO_UTILS_PRJ_TRACE)
	[ "$prj_path" == "" ] && echo -e "${red}[cmd_project_exec] Project $prj_name not found${norm}" && return
	(
	cd "$prj_path"
	eval "$prj_cmd"
	)
	}


# === service functions ===
get_current_set(){
	#local project_list=$1
	#if [[ "$project_list" == "" ]]; then
		local project_list="$(sed -E -n 's/^default_list=([^#]*)/\1/p' "$HOME/.utils-prj/$UTILS_PRJ_THE_HOST/default" | tr -d '\r')"
	# fi
	echo "$project_list" # return value
	}
get_project_name(){		# <project_path>
	# to test - bp; UTILS_PRJ_TRACE=1;get_project_name "/c/app/utils-env"
	local project_path="$1" 
	[ "$2" != "" ] && local UTILS_PRJ_TRACE=$2
	#log_print "root:\t\t$HOME/.utils-prj/$UTILS_PRJ_THE_HOST" 1>&2 # local root=$1; 
	#log_print "project_path:\t$project_path [get_project_name]" 1>&2
	#[[ "$root" == "" ]] && echo "[LIB: FIND PROJECT BY PATH] root for project is missed !" 1>&2 && return
	[[ "$project_path" == "" ]] && echo -e "${red}[get_project_name] param 'project_path' is missed !${norm}" 1>&2 && return # project_path=$(pwd)
	log_print "project_path:\t[get_project_name] $project_path" 1>&2
		#echo "[get_project_name] project_path is missed !" 1>&2 && return
	
	(
	cd "$HOME/.utils-prj/$UTILS_PRJ_THE_HOST" #[ $UTILS_PRJ_TRACE -eq 1 ] &&  pwd 
	find_path="find"
	[[ "$TERM" == "cygwin" ]] && find_path="$(cygpath-m "$EXEPATH")/usr/bin/find"
	log_print "find_path:\t[get_project_name] $find_path" 1>&2
	for prj_loop in $($find_path . -maxdepth 1 -type f ! -name "*.*" -a ! -name default -exec basename "{}" ';'); do # all files w/o extensions | sed 's/^\.\///'
		log_print "prj_loop:\t[get_project_name] $prj_loop" 1>&2
		looped_path=`eval echo $(sed -E -n 's/^path=([^#]+).*/\1/p' $HOME/.utils-prj/$UTILS_PRJ_THE_HOST/$prj_loop | tr -d '\r')` 
		log_print "looped_path:\t[get_project_name] $looped_path" 1>&2
		if [[ "$project_path" == "$looped_path" ]]; then
			echo $prj_loop
			return
		  fi
	  done
	)
  }
get_project_path(){		# <prj>
	local prj_name="$1"
	[ "$2" != "" ] && local UTILS_PRJ_TRACE="$2"
	local extra=$3
	[ "$extra" != "" ] && echo "[get_project_path] extra param is invalid!" 1>&2 && (log_print "extra:\t[get_project_path] $extra" 1>&2) && return 
	#[[ "$root" == "" ]] && echo "[LIB: FIND PROJECT PATH] root for project is missed !" 1>&2 && return ; log_print "root:\t\t$root [get_project_path]" 1>&2
	[[ "$prj_name" == "" ]] && echo "[get_project_path] project name is missed !" 1>&2 && (log_print "prj_name:\t\t[get_project_path] $prj_name" 1>&2) && return
	
	#(	cd "$HOME/.utils-prj/$UTILS_PRJ_THE_HOST"
		#local find_path="find"
		#[[ "$TERM" == "cygwin" ]] && find_path="$(cygpath-m "$EXEPATH")/usr/bin/find"
		#log_print "find_path:\t[get_project_path] $find_path" 1>&2

	local prj_file="$HOME/.utils-prj/$UTILS_PRJ_THE_HOST/$prj_name"
	[ ! -f "$prj_file" ] && echo -e "${red} Project file '$prj_file' not found !${norm}" 1>&2 && return
		#for prj_loop in $($find_path . -maxdepth 1 -type f ! -name "*.*" -a ! -name default -exec basename "{}" ';'); do  #| tr -d '\r' | sed 's/^\.\///' 
		#	log_print "prj_loop:\t[get_project_path] $prj_loop" 1>&2
		#	if [[ "$prj_name" == "$prj_loop" ]]; then
				local prj_path=`eval echo $(sed -E -n 's/^path=([^# ]+).*/\1/p' $prj_file | tr -d '\r')` # remove tilda for home path's
				echo $prj_path
		#		return
		#	  fi
		#  done
	#)
  }
get_object_type(){		# <prj|list>
	local obj=$1  	# project_or_list
	[ "$2" == "NO_UTILS_PRJ_TRACE" ] && local UTILS_PRJ_TRACE=0 # true / false
	[ "$obj" == "" ] && echo -e "${red}[get_object_type] param 'obj' is missed !${norm}" 1>&2 && return 

	local find_path="find" # linux/osx
	[[ "$TERM" == "cygwin" ]] && find_path="$(cygpath-m "$EXEPATH")/usr/bin/find" # in windows $EXEPATH ex. C:\app\git - std env by git bash
	log_print "find_path:\t[get_object_type] $find_path" 1>&2

	(
	cd "$HOME/.utils-prj/$UTILS_PRJ_THE_HOST"
	local fname
	for fname in $($find_path . -maxdepth 1 -type f ! -name default -exec basename "{}" ';'); do
		#fname=`echo $fname` #normalize (cut <CR>)
		local base="${fname%.[^.]*}" # Strip shortest match of . plus at least one non-dot char from end
		local ext="${fname:${#base} + 1}" # Substring from len of base thru end
		log_print "fname parse:\t[get_object_type] $base - $ext" 1>&2
		if [ "$base" == "$obj" ]; then
			if [ "$extension" == "list" ]; then
				echo "set"
			  else
				echo "project"
			  fi
			return
		  fi
	  done
	)
	}
get_sync_status(){		# <remote_mode>
	# ex. get_sync_status true # to compare with last commit from remote host
	# ??todo: return two out param ???  array?  or  pull/push/both/diverged only?
	local use_remote_host="$1"  	# true / false
	local result_format="$2" 		# when 'silent' then print yes/no else print msg for user 
	[ "$3" != "" ] && local UTILS_PRJ_TRACE=$3
	echo use_remote_host: $use_remote_host 1>&2
	[ "$use_remote_host" == "" ] && use_remote_host=local
	[ "$result_format" == "" ] && result_format=notice

	log_print "use_remote_host: [get_sync_status] $use_remote_host" 1>&2
	log_print "result_format:\t[get_sync_status] $result_format" 1>&2

	[[ "$result_format" == "notice" && "$use_remote_host" == "local" ]] && echo -e -n "Ask ${green}$use_remote_host${norm} for last commit .. " 1>&2
	[[ "$result_format" == "notice" && "$use_remote_host" == "remote" ]] && echo -e -n "Ask ${green}$use_remote_host${norm} for last commit .. " 1>&2

	#log_print $([ "$result_format" != "silent" ] && echo "notice mode [get_sync_status]") 1>&2
	local status
	local LOCAL=$(git rev-parse HEAD) # хеш коммита для указанной ревизии - @ alone is a shortcut for HEAD.
	if [[ "$use_remote_host" == "true" ]]; then
		echo -remote-
		local REMOTE=$(git ls-remote 2>/dev/null | awk "/HEAD/ {print \$1}") # from remote host
	  else
		local REMOTE=$(git rev-parse @{u}) # last pulled head of remote
	  fi
	local BASE=$(git merge-base @ @{u}) # merge-base возвращает ближайшего общего предка для двух веток, то есть sha-id какого-то комита;   @{u} = @{upstream}
	#echo LOCAL:$LOCAL REMOTE:$REMOTE BASE:$BASE
	if [ $LOCAL = $REMOTE ]; then 		status="ok" # same
	  elif [ $LOCAL = $BASE ]; then		status="pull"
	  elif [ $REMOTE = $BASE ]; then	status="push"
	  else				  	status="diverged"
	  fi

	local changes=`echo $(git status -s --untracked-files | wc -l)` # cut tab
	if [ "$result_format" == "notice" ]; then
		[[ "$status" == "ok" && "$changes" != "0" ]] 	&& echo -e "${yellow}NEED TO COMMIT AND PUSH${norm}" 1>&2
		[[ "$status" == "ok" && "$changes" == "0" ]]	&& echo -e "${green}same${norm}" 1>&2
		[ "$status" == "pull" ] 			&& echo -e "${yellow}NEED TO PULL !${norm}" 1>&2
		[ "$status" == "push" ] 			&& echo -e "${green}NEED TO PUSH${norm}" 1>&2
		[ "$status" == "diverged" ] 			&& echo -e "${red_bright}DIVERGED !!${norm}" 1>&2 # ! NEED TO PUSH AFTER
	  fi
	log_print "status:\t\t[get_sync_status] $status" 1>&2
	log_print "changes:\t[get_sync_status] $changes" 1>&2
	echo "$status" # for extra handle
	}
