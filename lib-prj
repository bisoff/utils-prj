#!/bin/bash
#set -x ?? setopt??  to trace one func

# globals: ==============================
trace=0
utils_prj_home=$(dirname ${BASH_SOURCE[0]})
utils_prj_the_host=$(uname -n)
utils_prj_configs=`eval echo ~/.utils-prj`
alias trace_prj='[ "$trace" == "1" ] && echo -e '

# TODO: =================================
	# project list commands
	# psets
	# psetadd
	# psetdel
	# psetren
	# psetsw

	# correct cmd_edit_host_config
	# rename list to set in helps ??
	# pcmd <prj> (execute cmd in prj home folder)
	# cmd_add_project(){ $3 - home_path
	# verbose to trace
	# empty params -> help
	# pmove to another list
	# plist add help header
	# show_sync_needed_status - both mode(pull/push)

	# support named params style: -v -h -n: -p: -l:(-s?) -m:"" 
	# -n=<prj> -p=<path> -t=<type> -r=<remote> -l(s?)=<list(set?)>
	#while :
	#do
	#    case "$1" in
	#    -h|--help) ;;
	#    -*) echo "invalid argument $1";;
	#    *) break;;
	#    esac
	#    shift
	#done
		# todo: add matrix of using cmd_<utils-git>
	# todo: when cmd_<utils-git> absent - show not found msg and prompt how to install
	# todo: [ "$trace" == "1" ] && echo -e ".."

	# todo: oldpwd for *nix (~/.oldpwd for msys only)

	# todo: how add to man
	# todo: how add to repo 4 install by installer

	# todo: prj type: rsync  svn  simple(compare size / timestamp)

	# todo: reference impl : clone setup psetadd cd padd plist cd- pgo touch pstate pstx pget psave psync pcmd (reset) ...
		# how todo remote commit (w/o push)

# release notes: ========================
	# тильда в переменной для указания в пути домашней папки- крэшит команды (cd, ls ..)
		# workaround: eval - http://stackoverflow.com/questions/11065077/eval-command-in-bash-and-its-typical-uses 
		# re="~(.*)"; if [[ $path =~ $re ]]; then  path=${BASH_REMATCH[1]}; fi; cd $HOME$path
	# to trace just set special var 'trace=1; <cmd>; trace=0'

# install functions======================
utils-prj-setup(){
	echo "unreleased"
	# check utils-git ->  if absent - msg - what commands willn't work
	# check utils-env ->  if absent - msg - colors will willn't work
	# copy 'include' to ~/.utils-prj
	# replace HOME_UTILS_PRJ in 'include' # to include lib to shell and some commands (ex. pel, p-help)
	# add '. ~/.utils-prj/include' to .bash_profile
	# ask PATH and add export PATH=$PATH:$HOME_UTILS_PRJ when absent! to include
	# show readme.md (setup info;  config files;  commands)
	}
utils-prj-uninstall(){
	echo "unreleased"
	# ask - add to PATH
	# copy 'include' to ~/.utils-prj
	# replace HOME_UTILS_PRJ in 'include'
	# add '. ~/.utils-prj/include' to .bash_profile
	}

# service functions======================
get_default_project_list () { 	# [<list>]
	local project_list=$1
	if [[ "$project_list" == "" ]]; then
		project_list="$(eval cat "$utils_prj_configs/$utils_prj_the_host/default" | sed -E -n 's/^default_list=([^#]*)/\1/p' | tr -d '\r')"
	 fi
	echo "$project_list" # return value
	}
get_project_name_verified () { 	# <prj>
	#local root=$1 #echo "root:$root"
	local prj=$1
	trace_prj "prj:\t\t$prj [get_project_name_verified]" 1>&2
	#[[ "$root" == "" ]] && echo "[LIB: FIND PROJECT] root for project is missed !" 1>&2 && return
	[[ "$prj" == "" ]] && echo "[LIB: FIND PROJECT] project name is missed !" 1>&2 && return
	
	( # to restore path after cd
	cd "$utils_prj_configs/$utils_prj_the_host" #$root
	find_path="find" # linux/osx
	[[ "$TERM" == "cygwin" ]] && find_path="$(cygpath-m "$EXEPATH")/usr/bin/find" # in windows $EXEPATH ex. C:\app\git - std env by git bash
	#$(cygpath-m "$EXEPATH") or canonpath after correct
	trace_prj "find_path:\t$find_path [get_project_name_verified]" 1>&2

	for prj_loop in $($find_path . -maxdepth 1 -type f ! -name "*.*" -a ! -name default | sed 's/^\.\///' ); do # all files w/o extensions
		trace_prj "prj_loop:\t$prj_loop [get_project_name_verified]" 1>&2
		if [[ "$prj" == "$prj_loop" ]]; then
			echo $prj_loop # return alias (name) of project if found
			return
		  fi
	  done
	)
  }
get_projectName_findByPath () { # <project_path>
	# to test - bp; trace=1;get_projectName_findByPath "/c/app/utils-env"
	local project_path=$1; 
	[ "$2" != "" ] && local trace=$2
	#[ "$trace" == "1" ] && echo -e "root:\t\t$utils_prj_configs/$utils_prj_the_host" 1>&2 # local root=$1; 
	trace_prj "project_path:\t$project_path [get_projectName_findByPath]" 1>&2
	#[[ "$root" == "" ]] && echo "[LIB: FIND PROJECT BY PATH] root for project is missed !" 1>&2 && return
	[[ "$project_path" == "" ]] && echo "[get_projectName_findByPath] project_path is missed !" 1>&2 && return
	
	(
	cd "$utils_prj_configs/$utils_prj_the_host" #[ $trace -eq 1 ] &&  pwd 
	find_path="find"
	[[ "$TERM" == "cygwin" ]] && find_path="$(cygpath-m "$EXEPATH")/usr/bin/find"
	trace_prj "find_path:\t$find_path [get_projectName_findByPath]" 1>&2
	for prj_loop in $($find_path . -maxdepth 1 -type f ! -name "*.*" -a ! -name default | sed 's/^\.\///' ); do # all files w/o extensions
		trace_prj -n "prj_loop:\t$prj_loop [get_projectName_findByPath]" 1>&2
		looped_path=`eval echo $(sed -E -n 's/^path=([^#]+).*/\1/p' $utils_prj_configs/$utils_prj_the_host/$prj_loop | tr -d '\r')` 
		trace_prj "\tlooped_path:\t$looped_path [get_projectName_findByPath]" 1>&2
		if [[ "$project_path" == "$looped_path" ]]; then
			echo $prj_loop
			return
		  fi
	  done
	)
  }
get_projectPath_findByName () {	# <prj>
	local prj=$1
	local extra=$2
	[ "$extra" != "" ] && echo "[get_projectPath_findByName] extra param is invalid!" 1>&2 && (trace_prj "extra:\t$extra [get_projectPath_findByName]" 1>&2) && return 
	#[[ "$root" == "" ]] && echo "[LIB: FIND PROJECT PATH] root for project is missed !" 1>&2 && return ; [ "$trace" == "1" ] && echo -e "root:\t\t$root [get_projectPath_findByName]" 1>&2
	[[ "$prj" == "" ]] && echo "[get_projectPath_findByName] project name is missed !" 1>&2 && (trace_prj "prj:\t\t$prj [get_projectPath_findByName]" 1>&2) && return
	(
	cd "$utils_prj_configs/$utils_prj_the_host"
	local find_path="find"
	[[ "$TERM" == "cygwin" ]] && find_path="$(cygpath-m "$EXEPATH")/usr/bin/find"
	trace_prj "find_path:\t$find_path [get_projectPath_findByName]" 1>&2
	for prj_loop in $($find_path . -maxdepth 1 -type f ! -name "*.*" -a ! -name default | sed 's/^\.\///' ); do  #| tr -d '\r'
		trace_prj "prj_loop:\t$prj_loop [get_projectPath_findByName]" 1>&2
		if [[ "$prj" == "$prj_loop" ]]; then
			local prj_path=`eval echo $(sed -E -n 's/^path=([^# ]+).*/\1/p' $utils_prj_configs/$utils_prj_the_host/$prj_loop | tr -d '\r')` # remove tilda for home path's
			echo $prj_path
			return
		  fi
	  done
	)
  }
show_sync_needed_status(){	# <remote_mode>
	# ex. show_sync_needed_status true # to compare with last commit from remote host
	# ??todo: return two out param ???  array?  or  pull/push/both/diverged only?
	local use_remote_host=$1  	# true / false
	local result_format=$2 		# when 'simple' then print yes/no else print msg for user 
	[ "$result_format" == "" ] && result_format=simple
	[ "$use_remote_host" == "" ] && use_remote_host=false
	trace_prj "result_format:\t\t$result_format [show_sync_needed_status]" 1>&2
	local LOCAL=$(git rev-parse @)
	if [[ "$use_remote_host" == "true" ]]; then
		local REMOTE=$(git ls-remote 2>/dev/null | awk "/HEAD/ {print \$1}")
	  else
		local REMOTE=$(git rev-parse @{u}) # from local
	  fi
	local BASE=$(git merge-base @ @{u})
	#echo LOCAL:$LOCAL REMOTE:$REMOTE BASE:$BASE
	if [ $LOCAL = $REMOTE ]; then
	  	if [ "$result_format" == "simple" ]; then 
	  		echo "ok" 
	  	  # else true?
	  	  fi
	  elif [ $LOCAL = $BASE ]; then
	  	if [ "$result_format" == "simple" ]; then 
	  		echo "pull"
	  	  else
			echo -e "${yellow} NEED TO PULL !${norm}"
		  fi
	  elif [ $REMOTE = $BASE ]; then
	  	if [ "$result_format" == "simple" ]; then 
	  		echo "push"
	  	  else
			echo -e "${yellow}NEED TO PUSH !${norm}" 
		  fi
		#true #echo "Need to push"
	  else
	  	if [ "$result_format" == "simple" ]; then 
	  		echo "diverged"
	  	  else
			echo -e "${red_bright} DIVERGED !!${norm}" # ! NEED TO PUSH AFTER
		  fi
	  fi
	}

# config functions ======================
cmd_edit_host_config(){		# ped	[<list>]
	# ped [<list>]	
	# edit default or specified repo list

	utility_path=$(echo "`dirname \"$0\"`")

	# get host
	host="$(cat $utility_path/.cfg/default.cfg | sed -E -n "s/^host=([^#]*)/\1/p")" # host alias
	#echo utils_prj_the_host:$utils_prj_the_host

	# get prj list
	repos=$1
	if [[ "$repos" == "" ]]; then
		repos="$(cat $utility_path/.cfg/default.cfg | sed -E -n "s/^default_list=([^#]*)/\1/p")"
	 fi

	ed $repos
	}
cmd_list_projects(){		# plist	[<list>]
	# plist <list>
	# echo utils_prj_the_host: $utils_prj_the_host
	prj_list=$1
	prj_list=$(get_default_project_list $prj_list)  # verify
	#echo REPO LIST: $repos
	echo "========= $repos ========="

	for prj_name in $(cat $utils_prj_configs/$utils_prj_the_host/$repos.list | sed -e /^$/d | tr -d '\r' | sort); do 
		prj_name=`echo $prj_name` #normalize
		path=`sed -E -n 's/^path=([^#]+).*/\1/p' $utils_prj_configs/$utils_prj_the_host/$prj_name | tr -d '\r'` # sed -E -n 's/^path=([^#]+)/\1/p' /Users/a.bysov/prj/utils-vcs/.cfg/ok/ue
		( # to return curr path
		echo -e "$prj_name:\t$path"
		)
	  done
	}
cmd_add_project(){		# padd	<prj> [<list>] 
	# cmd_add_project <prj> [<list>] 
	# cmd_add_project -n=<prj> -p=<path> -t=<type> -r=<remote> -s=<set>
	local prj_name=$1
	local prj_list=$2

	[[ "$prj_name" == "" ]] && echo -e "${red}[PROJECT ADD] prj_name name is missed !${norm}" && return 
	local curr_path="${PWD/#$HOME/~}"; [ "$trace" == "1" ] && echo -e "cur_path:\t$curr_path"
	
	# TODO: detect repo type (git/svn/hg - .git foder / .svn folder? / ..)
	# TODO: return when curr_path not repo

	home=$(home); [ "$trace" == "1" ] && echo -e "home:\t\t$utils_prj_home"
	[ "$trace" == "1" ] && echo -e "utils_prj_the_host:\t\t$utils_prj_the_host"

	if [[ "$prj_list" == "" ]]; then
		prj_list_default=$(get_default_project_list); [ "$trace" == "1" ] && echo -e "default_list:\t $prj_list_default"
		[ "$prj_list_default" == "" ] && echo -e "${red}[PROJECT ADD] prj_list_default not found !${norm}" && return
		prj_list="$prj_list_default.list"
	  else
	  	prj_list="$prj_list.list"
	  fi
	[ "$trace" == "1" ] && echo -e "prj_list:\t$prj_list"
		
	prj_file="$utils_prj_configs/$utils_prj_the_host/$prj_name"
	 [ "$trace" == "1" ] && echo -e "prj_file:\t$prj_file"
	[[ -f $prj_file ]] && echo -e "${red}[PROJECT ADD] Project already exists${norm}" && return

	echo "path=$curr_path" 	> $prj_file
	echo "type=git" 	>> $prj_file
	echo "remote=" 		>> $prj_file

	# TODO: test prj_name in list
	# TODO: detect tail CR and don't append \n
	prj_list="$utils_prj_configs/$utils_prj_the_host/$prj_list"
	echo -e "$prj_name" >> "$prj_list"
	# TODO: if file exists but absenr in default list then add

	# shift loop
	# if $prj_name == "" then folder
	# if $path == "" then pwd
	# if $type == "" then git
	# if $remote == "" then current
	# if $set == "" then default
	}
cmd_delete_project(){
	# pdel -n=<prj> -p=<path> -s=<set>
	echo "unreleased"
	# alias pcfg='cmd_cfg' ???
	# pcfg <option>=<value>
	# pcfg --switch_default_prj_list=<prj_list>
	# pcfg --default_project=<prj>

	# shift loop
	# if $path == "" then pwd
	# if $prj == "" then folder
	# if $set == "" then default

	# loop set of prj (if $1 == "" then default)
	# if prj == $prj then rm
	# extract path
	# if path == $path then rm
	}
cmd_move_project(){		# pmove	<prj>|. [<list>]
	# pmove <prj> [<list>] - upd path of prj (find prj by name)

	prj_name=$1
	#[[ "$prj_name" == "" ]] && echo -e "${red}[PROJECT MOVE] Project name is missed !${norm}" && return
	#list=$2

	#new_path=$(pwd) #; echo new_path: $new_path
	curr_path="${PWD/#$HOME/~}" # replace $HOME to ~

	# TODO: detect repo type (git/svn/hg - .git foder / .svn folder? / ..) and return if new_path not a repo 

	# echo utils_prj_the_host: $utils_prj_the_host

	if [[ "$list" == "" ]]; then
		prj_list=$(get_default_project_list).list 
	  else
	  	prj_list="$list.list"
	  fi
	# echo "prj_list: $prj_list"
	# TODO: test prj in list
	#return

	[[ ! -f "$utils_prj_configs/$utils_prj_the_host/$prj_name" ]] && echo -e "${red}[PROJECT MOVE] Project file not found (by name) !${norm}" && return
	#echo sed -i '' -E "'s/^(path=)(.*)/\1${curr_path//\//\\/}/g'" "$utils_prj_configs/$utils_prj_the_host/$prj_name" #;  return 
	sed -i -E "s/^(path=)(.*)/\1${curr_path//\//\\/}/g" "$utils_prj_configs/$utils_prj_the_host/$prj_name" || return #  replace home path

	cmd_list_projects # plist
	}
cmd_rename_project(){		# ren 	<prj>
	# pren <prj> [<list>]  - rename prj name (alias) (find prj by curr_path)
	# pren -n=<prj> -p=<path> -t=<type> -r=<remote> -s=<set>

	#trace=0
	new_prj_name=$1
	[[ "$new_prj_name" == "" ]] && echo -e "${red}[PROJECT RENAME] Project name not found !${norm}" && return
	#list=$2

	#new_path=$(pwd) #; echo new_path: $new_path
	curr_path="${PWD/#$HOME/~}" # replace $HOME to ~

	# TODO: detect repo type (git/svn/hg - .git foder / .svn folder? / ..) and return if new_path not a repo 

	[ $trace -eq 1 ] && echo -e "utils-home:\t$utils_prj_home"
	[ $trace -eq 1 ] && echo -e "utils_prj_the_host: $utils_prj_the_host"

	if [[ "$list" == "" ]]; then
		prj_list=$(get_default_project_list).list 
	  else
	  	prj_list="$list.list"
	  fi
	[ $trace -eq 1 ] && echo "prj_list: $prj_list"
	# TODO: test prj in list
	#return
	curr_path=`eval echo $curr_path` # replace '~'' -> $HOME

	curr_prj_name=$(get_projectName_findByPath $curr_path $trace) ; [ $trace -eq 1 ] && echo curr_prj_name: $curr_prj_name	 #old prj name
	[[ "$curr_prj_name" == "" ]] && echo -e "${red}[PROJECT RENAME] Project file not found !${norm}" && return
	  #prj_path=`sed -E -n 's/^path=([^#]+).*/\1/p' $utils_prj_configs/$utils_prj_the_host/$new_prj_name | tr -d '\r'` #; echo curr_path: $prj_path
	#echo sed -i "s/^$curr_prj_name\$/$new_prj_name/g" "$utils_prj_configs/$utils_prj_the_host/$prj_list" ; return
	mv "$utils_prj_configs/$utils_prj_the_host/$curr_prj_name" "$utils_prj_configs/$utils_prj_the_host/$new_prj_name" || return

	sed -i -E "s/^$curr_prj_name\$/$new_prj_name/g" "$utils_prj_configs/$utils_prj_the_host/$prj_list" || return # sed -i "s/^jr$/jrhw/g" `echo $utils_prj_configs/$utils_prj_the_host/$(get_default_project_list).list`

	#echo "path=$new_path" 	>  $prj_path
	#echo "type=git" 	>> $prj_file
	#echo "remote=" 		>> $prj_file

	plist

	# TODO: if file exists but absenr in default list then add

	# shift loop
	# if $new_prj_name == "" then folder
	# if $path == "" then pwd
	# if $type == "" then git
	# if $remote == "" then current
	# if $set == "" then default
	}
#cmd_edit_host_config

# navigate and state functions===========
cmd_go_to_project_home(){	# pgo 	<prj> [<list>?] # dubl aliases?
	# pgo <project> 
	#trace=0
	[ $SHLVL -gt 1 ] && echo "[GO TO PROJECT] Subshell can't change path after return ! CORRECT USE: '. pgo <project>'" 1>&2 && return
	#if expr match $parent $(which vim) > /dev/null

	#me=`dirname ${BASH_SOURCE[0]}` ; [ $trace -eq 1 ] && echo "utility path: $me"
	#. $me/lib-prj

	project="$1" # test 1st param - prj name
	[[ "$project" == "" ]] && echo "[GO TO PROJECT] project name is missed !"

	trace_prj "utils_prj_home:\t$utils_prj_home"
	trace_prj "utils_prj_the_host: $utils_prj_the_host"
		# repos=$1; repos=$(get_default_project_list $repos) # echo repos: $repos
	#echo path: "$utils_prj_configs/$utils_prj_the_host" 
	#get_project_name_verified "$utils_prj_configs/$utils_prj_the_host" $project
	prj_repo=$(get_project_name_verified $project) 
	trace_prj "prj_repo:\t$prj_repo" # "$utils_prj_configs/$utils_prj_the_host" 
	[[ "$prj_repo" == "" ]] && echo "[GO TO PROJECT] project '$project' not found !" && return
	# extract path of repo
	project_path="$(sed -E -n 's/^path=([^#]*)/\1/p' $utils_prj_configs/$utils_prj_the_host/$prj_repo | tr -d '\r')" 
	trace_prj "project_path:\t$project_path"

	echo "go to: $project_path"
	# ??TODO: test $path exists
	eval cd "$project_path"
	[ "$ConEmuPID" != "" ] && $ConEmuBaseDir/ConEmuC -GuiMacro Rename 0 "${PWD##*/}" 1> /dev/null
	[ "$TERM_PROGRAM" == "Apple_Terminal" ] && echo -ne "\033]0;${PWD##*/}\007"
	}
cmd_state_of_one_project(){	# pstate <prj>
	# pstate <prj>
	prj=$1
	# echo home: $home
	# echo utils_prj_the_host: $utils_prj_the_host
	if [[ "$prj" == "" ]]; then 
		curr_path=`eval echo $(pwd)`; [ "$trace" == "1" ] && echo -e "cur_path:\t$curr_path"
		prj_name=$(get_projectName_findByPath $curr_path); [ "$trace" == "1" ] && echo -e "prj_name:\t$prj_name"
		[[ "$prj_name" == "" ]] && echo "[SAVE PROJECT] project name is missed  and  not found by 'current path' in $utils_prj_configs/$utils_prj_the_host !" && return
		# save prj
		gis
		show_sync_needed_status false
		return
	  fi

	# find prj file by current path
	prj_path=$(get_projectPath_findByName $prj) #"$utils_prj_configs/$utils_prj_the_host" 
	# TODO: get prj vcs_type (svn, git)
	( # to return current path
	echo -e "$prj:\t$prj_path"
	eval cd "$prj_path"
	gis
	show_sync_needed_status false
	)
	}
cmd_state_of_all_projects(){	# pst[x] <list>|. 	# '.' for default list
	local prj_list=$1
	[ "$prj_list" == "" ] && prj_list=default
	[ "$remote_mode" == "" ] && remote_mode=false #$2
	[ "$trace" == "" ] && trace=0 #$3
	
	trace_prj "utils_prj_home:\t\t$utils_prj_home"
	trace_prj "utils_prj_the_host:\t$utils_prj_the_host"
	trace_prj "remote_mode:\t\t$remote_mode"
	
	[[ "$prj_list" == "default" ]] && prj_list=$(get_default_project_list)
	[ "$trace" == "1" ] && echo -e "prj_list:\t\ttrace$prj_list"
	#[[ "$remote_mode" == "" ]] && -e "${red}[lib-prj.:projects_state] 'remote_mode' param is not defined !${norm} " && return

	for prj in $(cat $utils_prj_configs/$utils_prj_the_host/$prj_list.list | sed -e /^$/d | tr -d '\r' | sort); do 
		prj=`echo $prj` # normalize
		prj_file=`echo $utils_prj_configs/$utils_prj_the_host/$prj`
		if [[ ! -f "$prj_file" ]]; then
			#echo prj: $utils_prj_configs/$utils_prj_the_host/$prj
			#cat $utils_prj_configs/$utils_prj_the_host/$prj
			echo -e "${red} Project file '$prj_file' not found !${norm} "
			continue
		  fi

		prj_file_norm=`eval echo $prj_file` #; echo prj_file_norm: $prj_file_norm
		#echo sed -E -n 's/^path=([^#]+).*/\1/p' "$prj_file_norm"
		#set -x
		path=`sed -E -n 's/^path=([^#]+).*/\1/p' "$prj_file_norm" | tr -d '\r'` ;[ "$trace" == "1" ] && echo -e "path:\t\t\t$path"
		#set +x
		prj_path_norm=`eval echo $path` #; echo prj_path_norm: $prj_path_norm
		[[ ! -d $prj_path_norm ]] && echo -e "${red} Project path '$path' not found !${norm} " && continue
		(
		eval cd "$path"
		changes=$(gis | wc -l) #; [ $trace -eq 1 ] && echo changes: $changes
		#	echo -e "${grey}$prj: $path${norm}"
		#  else

		echo -e "\n ${grey_back} $prj_list  $prj \t $path ${norm}"
		if [ $changes -ne 0 ]; then
			git status -s --untracked-files
		  fi

		show_sync_needed_status $remote_mode
		)
	  done
	echo
	}

# data sync =============================
cmd_save_one_projects(){	# psave <prj>|. [<msg>]
	# psave <prj> <msg> # save prj-repo (add/commit/push)
	# todo: . <msg>
	# to trace - 'bp; trace=1; psave kj'
	local prj=$1
	local msg=$2
	
	[ "$prj" == "" ] && echo "psave <prj>|. [<msg>]" && return 
	[ "$trace" == "1" ] && echo -e "prj:\t\t$prj"
	# echo utils_prj_home: $utils_prj_home
	# echo utils_prj_the_host: $utils_prj_the_host
	#default_repos=$(get_default_project_list) 	# echo default_repos: $default_repos  # get default repos  

	if [[ "$prj" == "." ]]; then 
		curr_path=`eval echo $(pwd)` #; echo cur_path:$curr_path
		prj_name=$(get_projectName_findByPath $curr_path)
		[ "$trace" == "1" ] && echo -e "prj_name:\t$prj_name"
		[[ "$prj_name" == "" ]] && echo "[SAVE PROJECT] project name is missed  and  not found by 'current path' in $utils_prj_configs/$utils_prj_the_host !" && return
		# save prj
		echo "SAVING $prj_name: $curr_path"
		gok
		return
	  fi

	# find prj file by current path
	local prj_path=$(get_projectPath_findByName $prj)
	[ "$trace" == "1" ] && echo -e "prj_path:\t$prj_path" #"$utils_prj_configs/$utils_prj_the_host" 
	[ "$prj_path" == "" ] && echo -e "${red}[SAVE PROJECT] prj_path not found !${norm}" && return
	local prj_path_norm=`eval echo $prj_path`
	[ "$trace" == "1" ] && echo -e "prj_path_norm:\t$prj_path_norm"
	#[[ "$prj_path_norm" == "" ]] && echo -e "${red}[SAVE PROJECT] project file '$utils_prj_configs/$utils_prj_the_host/$prj' not found !${norm}" && return
	[[ ! -d "$prj_path_norm" ]] && echo -e "${red}[SAVE PROJECT] project path '$prj_path_norm' not found !${norm}" && return
	# TODO: get prj vcs_type (svn, git)
	# TODO: get prj remote

	( # to return current path
	echo -e "prj_path:\t$prj_path"
	eval cd "$prj_path"
	gok "$msg" 
	)
	# TODO: test uncommited (untracked, changed, deleted, staged)
	}
cmd_save_all_projects(){	# psavall <list>|. [<msg>]
	# psavall <msg> <list>  # save every prj in list (add/commit/push)
	list=$1
	msg=$2

	[ "$trace" == "1" ] && echo -e "utils_prj_home:\t$utils_prj_home"
	[ "$trace" == "1" ] && echo -e "utils_prj_the_host:\t$utils_prj_the_host"

	[[ "$list" == "." ]] && list="" # trik to save default
	[[ "$list" == "" ]] && list=$(get_default_project_list)
	# echo list: $list  		# get default repos list

	for prj in $(cat $utils_prj_configs/$utils_prj_the_host/$list.list | tr -d '\r' | sort); do 
		path=`sed -E -n 's/^path=([^#]+).*/\1/p' $utils_prj_configs/$utils_prj_the_host/$prj | tr -d '\r'` # sed -E -n 's/^path=([^#]+)/\1/p' /Users/a.bysov/prj/utils-vcs/.cfg/ok/ue
		(
		eval cd "$path"
		changes=$(gis | wc -l)	# echo changes: $changes
		echo -e "\n${grey_back}$prj: $path${norm}"
		if [ $changes -ne 0 ]; then
			gok "$msg" # TODO: переделать на использование либы 
			echo
		  fi
		#${red}none${norm}"
		)
	  done

	# TODO: test uncommited (untracked, changed, deleted, staged)
	}
cmd_save_one_project_at_local(){ # pfix <prj> <msg>
	# pfix <prj> <msg> # save prj-repo (add/commit/push)

	prj=$1
	msg=$2

	# echo utils_prj_the_host: $utils_prj_the_host
	#default_repos=$(get_default_project_list) 	# echo default_repos: $default_repos  # get default repos  

	if [[ "$prj" == "" ]]; then 
		curr_path=`eval echo $(pwd)` #; echo cur_path:$curr_path
		prj_name=$(get_projectName_findByPath $curr_path) #; echo prj_name: $prj_name
		[[ "$prj_name" == "" ]] && echo "[SAVE PROJECT] project name is missed  and  not found by 'current path' in $utils_prj_configs/$utils_prj_the_host !" && return
		# save prj
		echo "SAVING $prj_name: $curr_path"
		gac "$msg" 
		return
	  fi

	# find prj file by current path
	prj_path=$(get_projectPath_findByName $curr_path $prj) #"$utils_prj_configs/$utils_prj_the_host"
	[[ "$prj_path" == "" ]] && echo  "[SAVE PROJECT] project file '$utils_prj_configs/$utils_prj_the_host/$prj' not found !" && return
	# TODO: get prj vcs_type (svn, git)
	# TODO: get prj remote
	( # to return current path
	echo "$prj: $prj_path"
	eval cd "$prj_path"
	gac "$msg" 
	)

	# TODO: test uncommited (untracked, changed, deleted, staged)
	}
cmd_pull_one_project(){		# pget 	<prj> 
	# pget <prj> 

	#trace=0
	prj=$1
	msg=$2
	#[ $trace == 1 ] && echo start
	[ $trace == 1 ] && echo -e "utils_prj_the_host:\t$utils_prj_the_host"

	curr_path=$(pwd) ; [ $trace == 1 ] && echo curr_path: $curr_path	
	if [[ "$prj" == "" ]]; then 
		curr_path=`eval echo $(pwd)` #; echo cur_path:$curr_path
		prj_name=$(get_projectName_findByPath $curr_path) #; echo prj_name: $prj_name
		[[ "$prj_name" == "" ]] && echo "[SAVE PROJECT] project name is missed  and  not found by 'current path' in $utils_prj_configs/$utils_prj_the_host !" && return
		# get prj (update)
		echo "GETTING $prj_name: $curr_path"
		gul
		return
	  fi

	# find prj file by current path
	prj_path=$(get_projectPath_findByName "$prj"); [ $trace == 1 ] && echo prj_path: $prj_path # "$utils_prj_configs/$utils_prj_the_host"
	[[ "$prj_path" == "" ]] && echo -e "${red}[PROJECT GET] Project path not found (by name: $prj) ! ${norm}" && return
	# TODO: get prj vcs_type (svn, git)
	# TODO: get prj remote
	( # to return current path
	echo "$prj: $prj_path"
	eval cd "$prj_path"
	gul "$msg" 
	)
	# TODO: test uncommited (untracked, changed, deleted, staged)
	}
cmd_pull_all_projects(){	# pgetall <list>|.
	# pgetall <list> # save every prj in list (add/commit/push)
	prj_list=$1

	# echo home: $home
	# echo utils_prj_the_host: $utils_prj_the_host
	[[ "$prj_list" == "." ]] && prj_list="" # trik to set default
	[[ "$prj_list" == "" ]] && prj_list=$(get_default_project_list)
	trace_prj "prj_list:\t\t$prj_list" # get default repos list

	for prj in $(cat $utils_prj_configs/$utils_prj_the_host/$prj_list.list | tr -d '\r' | sort ); do 
		path=`sed -E -n 's/^path=([^#]+).*/\1/p' $utils_prj_configs/$utils_prj_the_host/$prj | tr -d '\r'` # sed -E -n 's/^path=([^#]+)/\1/p' /Users/a.bysov/prj/utils-vcs/.cfg/ok/ue
		(
		eval cd "$path"

		echo -e "\n ${grey_back} $prj_list  $prj \t $path ${norm}"
		changes=$(gis | wc -l) 
		trace_prj "changes:\t$changes" # 2> /dev/null 

		if [ $changes -eq 0  -o  "$changes" == "" ]; then
			compare_status=$(show_sync_needed_status)
			trace_prj "compare_status:\t$compare_status"
			[ "$compare_status" == "diverged" ] && echo -e "${red_bright}DIVERGED ! NEED TO PUSH AFTER ${norm}" # 
			if [ "$compare_status" == "pull" ]; then
				gul
				git diff --stat=200 HEAD~1 HEAD --color | sed -n '$! p' # files in last commit 
			  fi
		  else
    		  	gis
		  fi
		)
	  done
	# TODO: test uncommited (untracked, changed, deleted, staged)
	}
cmd_sync_one_project(){		# psync <prj>|. [<msg>]
	# psync <prj> <msg> # a) fix prj when need (add/commit) 2) pull when need  3) push when need

	# test 1st param - repo name
	prj=$1
	msg=$2

	# echo home: $home
	# echo utils_prj_the_host: $utils_prj_the_host

	if [[ "$prj" == "" ]]; then 
		curr_path=$(pwd) #; echo cur_path:$curr_path # replace 
		prj_name=$(get_projectName_findByPath $curr_path) #; echo prj_name: $prj_name
		[[ "$prj_name" == "" ]] && echo "[PROJECT SYNC] project name is missed  and  not found by 'path=' in $utils_prj_configs/$utils_prj_the_host !" && return
	  fi

	# TODO: get prj vcs_type (svn, git)
	# TODO: get prj remote

	( # to return current path
	echo "$prj: $prj_path"
	eval cd "$prj_path"
	echo "prj_name: $prj_name"

	# fix prj when need (add/commit) 
	#gac "$msg" 

	# pull when need  
	gul

	# push when need
	gus
	return
	)



	# TODO: test uncommited (untracked, changed, deleted, staged)
	}


